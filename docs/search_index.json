[
["index.html", "[2019 UST 일반강의] R 프로그래밍과 데이터 분석 1 Lecture 개요 1.1 Goal 강의 목표 1.2 References 참고 자료 1.3 Evaluation 평가 세부 항목 1.4 Schedule 강의 계획 1.5 Lecture note 강의 자료", " [2019 UST 일반강의] R 프로그래밍과 데이터 분석 Haseong Kim 2019-06-05 1 Lecture 개요 장소: 한국생명공학연구원 연구동 세미나실 1213호 (매주수요일 13:00~16:00) 강사: 한국생명공학연구원 바이오합성연구센터 김하성 연락처: 042-860-4372, haseong@kribb.re.kr (생명연 연구동 1143) homepage: https://greendaygh.github.io/Rprog2019/ https://github.com/greendaygh/Rprog2019 1.1 Goal 강의 목표 이공계열 대학원생이 통계 분석용 범용 프로그램 언어인 R의 사용법을 익히고 이를 이용한 프로그래밍 기술의 습득을 주요 목적으로 함. 생물 데이터 위주의 분석 예제를 통해 R의 활용 기술을 배움. 이 강좌는 오프라인 강의를 기본으로 함. R 사용에 대한 기본 개념과 프로그래밍을 중심으로 필요시 기초 통계지식 강의. 실습 데이터로는 주로 생물데이터를 사용함. 모든 강의 시간 실습을 위한 개인 노트북 지참 필수. 강의 자료는 pdf로 제작하여 수업 진행과 관련된 정보와 함께 웹사이트를 통해 배포됨. 상황에 따라 강의 일정이 조정될 수 있음. 1.2 References 참고 자료 R for Data Science (https://r4ds.had.co.nz, https://github.com/hadley) Using R for Introductory Statistics by John Verzani Free version of 1st Edition https://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf http://cbb.sjtu.edu.cn/~mywu/bi217/usingR.pdf Second edition https://www.crcpress.com/Using-R-for-Introductory-Statistics-Second-Edition/Verzani/p/book/9781466590731 Bioinformatics Data Skills by Vince Buffalo https://resources.rstudio.com/ 일반통계학 (영지문화사, 김우철 외) 1.3 Evaluation 평가 세부 항목 출석 50% / 과제 50% / 수업참여 +alpha 1.4 Schedule 강의 계획 Introduction and installation of R/Rstudio R language basics Data manipulation Visualizing data in R Shiny for interactive applications in R Workflows with R scripts Working with Range Data Sequence analysis Clustering and significance testing with genomic data 1.5 Lecture note 강의 자료 1 (2019.03.06) - Introduction and installation of R/Rstudio, Basics of variables and functions 2 (2019.03.13) - R Basics - Objects (vector, factor, matrix) and functions 다음 시간 readxl, Biostrings 두 패키지 미리 설치한 후 강의 참석 부탁드립니다. 3 (2019.03.20) - R Basics II - file I/O 강의가 좀 빠르게 진행된 듯 합니다. 기본으로 제공되는 R 기능을 사용하기 보다는 함수나 프로그래밍 코딩 원리를 이해하기 위해 직접 함수를 만들어보는 연습을 하고 있으니 참고 하시고 다음 시간 전에 이번 시간 코드 복습하시고 오시면 도움이 되실 것 같습니다. 4 (2019.03.27) - R programming example - Maze Robot 5 (2019.04.03) - R programming example - Plate reader "],
["lecture-01-r-introduction.html", "2 Lecture 01 - R Introduction", " 2 Lecture 01 - R Introduction "],
["lecture-02-r-basics-i.html", "3 Lecture 02 - R basics I 3.1 exercise 2-1: who function", " 3 Lecture 02 - R basics I 3.1 exercise 2-1: who function 함수를 만들고 사용하는 실습입니다. name 함수를 이용하여 벡터 값들에 대한 이름을 할당할 수 있으며 who 라는 이름의 함수를 생성하여 input 파라메터의 값 중 50 이상의 사람들에 대한 인덱스를 얻고 (which), 이들의 ages &lt;- c(21, 55, 23, 53) names(ages) &lt;- c(&quot;John&quot;,&quot;James&quot;,&quot;Sara&quot;, &quot;Lilly&quot;) who &lt;- function(input){ greater_than_fifty_index &lt;- which(input &gt; 50) greater_numbers &lt;- input[greater_than_fifty_index] greater_names &lt;- names(greater_numbers) return(greater_names) } who(ages) ## [1] &quot;James&quot; &quot;Lilly&quot; "],
["lecture-03-r-basics-ii.html", "4 Lecture 03 - R Basics II 4.1 matrix (행렬) 4.2 data.frame 4.3 list 4.4 File 읽기/쓰기 4.5 Excel file 읽기/쓰기 4.6 Exercise 3-2 standard deviation 4.7 Exercise 3-3 barplot with error bars", " 4 Lecture 03 - R Basics II 4.1 matrix (행렬) 매트릭스는 2차원 행렬로 같은 형식의 데이터 값 (numberic, character, logical) 으로만 채워진 행렬을 말합니다. 메트릭스를 만드는 방법은 아래와 같으며 nrow와 ncol 파라메터에 행과 열의 수를 넣고 각 셀에 들어갈 값은 가장 앞에 위치한 data 파라메터에 넣어 줍니다 (?matrix로 파라메터 이름 확인). 메트릭스 인덱싱은 메트릭스 안의 값을 저장하거나 참조할때 (빼올때) 사용하는 방법입니다. 메트릭스 변수이름 바로 뒤에 대괄호를 이용해서 제어를 하며 대괄호 안에 콤마로 구분된 앞쪽은 row, 뒷쪽은 column 인덱스를 나타냅니다. row 또는 column에 해당하는 어느쪽에도 값을 넣지 않을 경우 그 row 또는 column 전체를 참조하게 됩니다. mymat &lt;- matrix(0, nrow=100, ncol=3) # 1 mymat[,1] &lt;- 1:100 # 2 mymat[,2] &lt;- seq(1,200,2) # 3 mymat[,3] &lt;- seq(2,200,2) # 4 여러 row나 column을 참조할 경우 아래와 같이 combine 함수를 사용하여 묶어줘야 하며 스칼라값을 더하거나 뺄 경우 vector / matrix 연산을 기본으로 수행합니다. mymat[c(2,3,4,5),2] # 5 mymat-1 # 6 mysub &lt;- mymat[,2] - mymat[,1] #7 sum(mysub) #8 sum(mysub^2) #8 4.2 data.frame 데이터프레임은 변수의 모임으로 형태는 매트릭스와 같으나 $ 기호를 이용하여 각 구성 변수를 참조할 수 있다는 점이 다릅니다. 또한 데이터프레임 또는 매트릭스의 row나 column에 이름이 주어져 있을 경우 이름을 따옴표(“)로 묶은 후 참조가 가능합니다. ## data.frame ids &lt;- 1:10 ids idnames &lt;- paste(&quot;Name&quot;, ids, sep=&quot;&quot;) idnames students &lt;- data.frame(ids, idnames) students class(students$ids) class(students$idnames) students$idnames students &lt;- data.frame(ids, idnames, stringsAsFactors = F) class(students$idnames) students$idnames students[1,] ## data frame indexing students$ids students[,1] students[,&quot;ids&quot;] 4.3 list 리스트는 변수들의 모임이라는 점에서 데이터프레임과 같으나 구성 변수들의 길이가 모두 같아야 하는 데이터프레임과는 달리 다른 길이의 변수를 모아둘 수 있는 점이 다릅니다. 리스트는 아래와 같이 대괄호 두 겹을 이용해 인덱싱을 합니다. ## list parent_names &lt;- c(&quot;Fred&quot;, &quot;Mary&quot;) number_of_children &lt;- 2 child_ages &lt;- c(4, 7, 9) data.frame(parent_names, number_of_children, child_ages) lst &lt;- list(parent_names, number_of_children, child_ages) lst[1] lst[[1]] class(lst[1]) class(lst[[1]]) lst[[1]][1] lst[[1]][c(1,2)] 4.4 File 읽기/쓰기 텍스트 파일의 경우 아래와 같이 csv 또는 txt 파일로 저장하여 메모장으로 열어 확인할 수 있으며 읽어올 경우 구분자 (sep 파라메터) 나 header를 (header 파라메터) 읽을지 읽지 않을지 등을 옵션으로 지정할 수 있습니다. x &lt;- c(1,2,3,4) y &lt;- c(5,6,7,8) xy&lt;-data.frame(x=x, y=y) write.table(xy, file=&quot;table_write.txt&quot;) write.table(xy, file=&quot;table_write.txt&quot;, quote=F) write.table(xy, file=&quot;table_write.txt&quot;, quote=F, row.names=F) write.table(xy, file=&quot;table_write.txt&quot;, quote=F, row.names=F, sep=&quot;,&quot;) write.table(xy, file=&quot;table_write.csv&quot;, quote=F, row.names=F, sep=&quot;,&quot;) mydata&lt;-read.table(file=&quot;table_write.csv&quot;) mydata&lt;-read.table(file=&quot;table_write.csv&quot;, sep=&quot;,&quot;) mydata&lt;-read.table(file=&quot;table_write.csv&quot;, sep=&quot;,&quot;, header=T) plot(mydata$x, mydata$z) 4.5 Excel file 읽기/쓰기 엑셀파일은 readxl 이라는 R 패키지를 활용하여 읽거나 쓸 수 있습니다. install.packages(&quot;readxl&quot;) 실습 파일은 형광 세포를 배양하여 형광리더기를 이용해 얻어진 실제 데이터이며 Rprog04-fl.xls 에서 다운로드 받을 수 있습니다. read_excel 함수를 이용하여 파일의 내용을 읽어오면 기본 자료형이 tibble 입니다. tibble은 최근 많이 쓰이는 R object로 data.frame과 유사하나 입력값의 type, name, rowname을 임으로 바꿀 수 없다는 점이 다릅니다. tibble에 익숙해지는 것이 좋으나 본 강의에서는 직관적인 진행을 위하여 data.frame으로 전환하여 사용하겠습니다. library(readxl) ## Warning: package &#39;readxl&#39; was built under R version 3.5.3 mydata &lt;- read_excel(&quot;Rprog04-fl.xls&quot;, sheet=2, skip = 6, col_names=F) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems myod &lt;- as.data.frame(mydata[1:8, ]) mygfp &lt;- as.data.frame(mydata[12:21, ]) class(myod[,1]) class(myod[,2]) 엑셀파일에는 두 종류의 (OD600nm, fluorescence) 데이터가 저장되어 있으며 각각을 위에서 1~8 row 그리고 12~21 row 값들을 모두 myod와 mygfp로 저장했습니다. 그러나 엑셀파일을 보면 첫번째 컬럼에 관측값 외에 다른 정보들에 대한 텍스트가 적혀 있으며 이로 인해 행렬의 가장 첫 컬럼의 데이터 타입이 character가 되고 나머지 컬럼은 numeric으로 자동 전환 되어 data.frame 오브젝트인 mydata에 저장되게 됩니다. 따라서 아래와 같이 문자형을 숫자형으로 전환하여 추후 연산을 진행하게 됩니다. myod[,1] &lt;- as.numeric(myod[,1]) mygfp[,1] &lt;- as.numeric(mygfp[,1]) 수행한 실험의 디자인에 따라서 두 그룹으로 나누고 적절한 이름을 저장합니다. myod_treat &lt;- myod[2:4,] myod_control &lt;- myod[5:7,] sample_names &lt;- paste(&quot;Sample&quot;, c(1:12), sep=&quot;&quot;) replicate_labels &lt;- paste(&quot;Rep&quot;, c(1:3), sep=&quot;&quot;) rownames(myod_treat) &lt;- replicate_labels colnames(myod_treat) &lt;- sample_names rownames(myod_control) &lt;- replicate_labels colnames(myod_control) &lt;- sample_names mean_treat &lt;- colMeans(myod_treat) mean_control &lt;- colMeans(myod_control) 위 예제의 colMean 과 같은 함수는 column 또는 row 단위로 해당하는 모든 값들에 대해 연산을 수행해주는 함수로 colMean은 평균을 계산하는 함수이고 일반적으로는 다음과 같이 apply 함수와 mean 함수를 이용해서 같은 기능을 수행할 수 있습니다. mean 함수 외 임의의 원하는 함수를 만들어 사용할 수 도 있습니다. 참고로 sd는 표준편차를 구해주는 함수 입니다. apply(myod_control, 1, mean) ## Rep1 Rep2 Rep3 ## 0.8069922 0.7706701 0.7873404 apply(myod_control, 2, mean) ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 Sample7 ## 0.7757480 0.7807732 0.7628736 0.7472908 0.7034527 0.6963549 0.8094640 ## Sample8 Sample9 Sample10 Sample11 Sample12 ## 0.8145531 0.8301742 0.8390556 0.8447189 0.8555517 apply(myod_control, 2, function(x){ xmean &lt;- mean(x) return(xmean) }) ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 Sample7 ## 0.7757480 0.7807732 0.7628736 0.7472908 0.7034527 0.6963549 0.8094640 ## Sample8 Sample9 Sample10 Sample11 Sample12 ## 0.8145531 0.8301742 0.8390556 0.8447189 0.8555517 apply(myod_control, 2, sd) ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 ## 0.015981356 0.023394455 0.032168135 0.034528460 0.035805916 0.014999636 ## Sample7 Sample8 Sample9 Sample10 Sample11 Sample12 ## 0.017801936 0.017947840 0.010253370 0.006202754 0.022386592 0.012685731 본 실습에서는 각 그룹의 평균을 비교하는 막대그래프를 그려보겠습니다. plot(mean_treat, type=&quot;h&quot;) barplot(mean_treat, ylim=c(0,1)) mean_test &lt;- data.frame(mean_treat, mean_control) barplot(t(mean_test), ylim=c(0,1), beside=T) 4.6 Exercise 3-2 standard deviation 앞서 사용한 sd 함수는 표준편차를 구해주는 기본 제공 함수입니다. 아래는 같은 기능을 하는 함수를 만들어 보는 실습 예제 입니다. ## excercise 3-2 mysd &lt;- function(x){ xmean &lt;- sum(x)/length(x) tmpdif &lt;- x-xmean xvar &lt;- sum(tmpdif^2)/(length(x)-1) xsd &lt;- sqrt(xvar) return(xsd) } x &lt;- sample(1:100, 10) mysd(x) ## [1] 27.95413 sd(x) ## [1] 27.95413 4.7 Exercise 3-3 barplot with error bars 앞서 그려본 막대그래프에 에러바를 넣어보는 코드 입니다. 먼저 평균과 표준편차 데이터를 apply 함수를 통해 얻어내고 barplot을 수행합니다. 에러바의 경우 arrows 함수를 사용하는데 사용되는 파라메터의 입력되는 값을 바꿔서 그림을 그려보면 그 의미를 파악하는데 도움이 되겠습니다. ## Exercise 3-3) barplot with sd control_mean &lt;- apply(myod_control, 2, function(x){mean(x)}) control_sd &lt;- apply(myod_control, 2, mysd) barplot(control_mean, width=0.83, space=0.2, col=&quot;gray&quot;, ylim=c(0,1)) arrows(0.5, control_mean[1], 0.5, control_mean[1]+control_sd[1], length=0.1, angle=90) arrows(0.5, control_mean[1], 0.5, control_mean[1]-control_sd[1], length=0.1, angle=90) lab &lt;- paste(&quot;SD:&quot;, round(control_mean[1]+control_sd[1],1)) text(0.5, control_mean[1]+control_sd[1]+0.05, labels = lab) arrows(1.5, control_mean[2], 1.5, control_mean[2]+control_sd[2], length=0.1, angle=90) arrows(1.5, control_mean[2], 1.5, control_mean[2]-control_sd[2], length=0.1, angle=90) lab &lt;- paste(&quot;SD:&quot;, round(control_mean[2]+control_sd[2],1)) text(1.5, control_mean[2]+control_sd[2]+0.05, labels = lab) 그러나 위 12개의 bar 모두에 대해서 arrows 함수를 그리기 보다는 for 문을 이용한 반복 실행을 수행하는 것이 효율적 입니다. for 문의 사용 형식과 반복 횟수 그리고 반복하며 변화되는 값을 갖는 변수에 대한 의미를 파악하고 사용하는 것이 중요합니다. for문의 사용법은 강의노트 를 참고하세요. ## Exercise 3-4) barplot with sd using for barplot(control_mean, width=0.83, space=0.2, col=&quot;gray&quot;, ylim=c(0,1)) for(i in 1:length(control_mean)){ xpos &lt;- 0.5+i-1 arrows(xpos, control_mean[i], xpos, control_mean[i]+control_sd[i], length=0.1, angle=90) arrows(xpos, control_mean[i], xpos, control_mean[i]-control_sd[i], length=0.1, angle=90) lab &lt;- paste(&quot;SD:&quot;, round(control_mean[i]+control_sd[i],1)) text(xpos, control_mean[i]+control_sd[i]+0.05, labels = lab) } 마지막으로 실습 예제 3-5는 엑셀파일 이름을 argument로 받아서 파일 내용을 읽고 데이터를 두 그룹으로 나누어 평균을 계산한 후 plot까지 그려주는 함수를 만드는 실습 예제 입니다. 다음 시간에 이어서 합니다. "],
["lecture-04-maze-robot.html", "5 Lecture 04 - Maze Robot 5.1 Parameter/Argument, Global/Local 5.2 Exercise 4-1: Matrix indexing 5.3 Top-down design 5.4 Exercise 4-2: Draw world 5.5 Exercise 4-4: Generate map 5.6 Draw blocks and walls 5.7 Move one step 5.8 Sleep for delay 5.9 Move 50 steps", " 5 Lecture 04 - Maze Robot 5.1 Parameter/Argument, Global/Local 이번 시간에는 함수와 메트릭스의 사용법을 익히기 위해서 재미있는(?) 간단한 프로그램을 만들어 보겠습니다. 정사각형 격자 안에서 랜덤하게 한 칸씩 움직이며 시작 점부터 끝 점까지 가는 로봇을 구현하고 이를 시각화하는 프로그램이 되겠습니다. 먼저 프로그래밍에서 함수는 중요한 개념입니다. 이를 이해하기 위해서 parameter (매개변수) 와 argument (전달인자), 그리고 global (전역) 변수와 local (지역) 변수의 개념을 확실히 이해해야 합니다. 아래 parameter와 argument를 구분하고 myfunc 안에 있는 a 변수의 값과 밖에 있는 a의 값을 구분해봅시다. a &lt;- 10 myfunc &lt;- function(b){ a &lt;- b/2 return(a) } myfunc(a) cat(a) ## global vs local a &lt;- 10 myfunc &lt;- function(a){ a &lt;- a/10 return(a) } myfunc(a) cat(a) 5.2 Exercise 4-1: Matrix indexing 0으로 채워진 3 x 3 메트릭스를 만들고 가장자리 값들을 1로 채우는 연습을 해봅니다. M &lt;- matrix(0, nrow=3, ncol=3) M[,1] &lt;- 1 M[,3] &lt;- 1 M[1,] &lt;- 1 M[3,] &lt;- 1 5.3 Top-down design 탑다운 방식의 프로그래밍 디자인방법은 간략히 다음과 같은 순서로 진행합니다. 1) Divide a big problem into smaller problems, 2) keep dividing until the small problem can be solved easily, 3) Solve the small problems, 4) Merge the solutions to solve the big problem 이 방법으로 길찾기 로봇을 구현하기 위해서는 다음과 같이 문제를 세분화 하겠습니다. 먼저 구성물은 지도와 로봇이 있고 지도에는 시작점, 끝점, 막힌곳, 로봇은 현재 위치, 이동함수 (규칙) 등이 있으면 될 것 같습니다. 그리고 이러한 상황을 보여주기 위한 그리기 기능도 필요해 보입니다. 참고로 강사 생각이며 각자 다르게 생각할 수 있습니다. 좀 더 자세한 내용은 강의노트를 참고하세요. 5.4 Exercise 4-2: Draw world 먼저 로봇이 다니는 지도를 그리기 위해서 plot 함수를 사용합니다. plot 함수는 가장 기본이 되는 그래픽 함수로 입력 값에 따른 다양한 기능을 수행하는 함수입니다. 자세한 내용은 ?plot으로 도움말을 참고 하세요. 8 x 8 크기의 지도에서 격자를 다음과 같이 그릴 수 있습니다. plot(0, type=&quot;n&quot;, ylim=c(1,8), xlim=c(1,8)) lines(x=c(1,1), y=c(1,8)) lines(x=c(2,2), y=c(1,8)) lines(x=c(3,3), y=c(1,8)) lines(x=c(4,4), y=c(1,8)) lines(x=c(1,8), y=c(1,1)) lines(x=c(1,8), y=c(2,2)) lines(x=c(1,8), y=c(3,3)) lines(x=c(1,8), y=c(4,4)) 그런데 반복되는 lines 함수를 사용하는 패턴을 보실 수 있습니다. 이런 경우 다음과 같이 for 문을 이용할 수 있습니다. for 문의 i는 임의의 변수로 뒤에 오는 1:8 까지의 값을 한번씩 갖게 되며 각 값을 갖는 동안 { } 안의 코드를 8번 반복 실행하게 됩니다. 이 때 i에 저장된 값을 lines 파라메터 값을 사용하면 효율적으로 원하는 기능을 구현할 수 있습니다. 마지막 points 함수는 적당한 위치 (아래 예제에서는 x=3, y=3)의 위치에 pch=16 모양을 cex=3 만큼 크게 그리라는 명령입니다. ?points 또는 ?pch 등의 도움말을 참고 하세요. plot(0, type=&quot;n&quot;, ylim=c(1,8), xlim=c(1,8)) for(i in 1:8){ lines(x=c(i,i), y=c(1,8)) lines(x=c(1,8), y=c(i,i)) } points(3,3, pch=16, cex=3) 이제 앞서 코드들을 종합해서 map과 로봇을 그려주는 draw_world 라는 함수로 만들어 보겠습니다. 입력 파라메터는 현재 로봇의 위치인 cur_x, cur_y로 하고 지도를 그린 후 cur_x와 cur_y에 점(로봇)을 그리는 함수 입니다. 그리는 기능이 전부이므로 NULL을 리턴하도록 합니다 (웹페이지 작성 특성상 리턴 명령은 사용하지 않았습니다). 함수 내에서 n &lt;- 8 로 한 것은 그 아래 코드들에서 공통적으로 같은 값(지도 크기)을 사용하므로 변수에 값을 지정한 후 사용할 경우 혹시 지도의 사이즈가 변경된다고 해도 모든 값들을 바꾸지 않고 n 값만 바꿔서 쉽게 기능을 적용하기 위함 입니다. draw_world &lt;- function(cur_x, cur_y){ n &lt;- 8 plot(0, type=&quot;n&quot;, ylim=c(1,n), xlim=c(1,n)) for(i in 1:n){ lines(x=c(i,i), y=c(1,n)) lines(x=c(1,n), y=c(i,i)) } points(x=cur_x, y=cur_y, pch=16, cex=3) #return(NULL) } 위와 같이 코드를 작성한 후 한 번 실행하여 메모리에 함수를 등록 합니다. 이후 부터는 draw_world 호출만으로 구현한 기능을 사용할 수 있습니다. 아래는 그 사용 예 입니다. cur_x 또는 cur_y에 값을 변경하여 넣어 줄 때 마다 다른 위치에 점이 그려지는 것을 확인할 수 있습니다. cur_x &lt;- 1 cur_y &lt;- 1 draw_world(cur_x, cur_y) draw_world(cur_x+1, cur_y) draw_world(cur_x+1, cur_y+1) 5.5 Exercise 4-4: Generate map 위 코드까지 작성했다면 어떤 식으로 로봇이 움직이는 것을 보여줄 수 있을지 추측할 수 있을 것입니다. 로봇이 적당한 위치로 움직이게 하고 draw_world 함수를 호출하는 과정을 반복하면 되는 것입니다. 그럼 로봇이 어떻게 어디로 움직일지를 결정하기 위해서 매트릭스를 구성해 보겠습니다. 이 매트릭스는 가상의 지도로 0과 1로 채워져 있으며 0은 로봇이 갈 수 있는 곳 1은 로봇이 가지 못하는 곳으로 정하고 로봇이 랜덤하게 움직이며 이동한 곳이 0인지 1인지 검사해서 이동을 완료할지 아니면 그 전 위치에서 다시 움직일 곳을 찾을지를 결정하면 됩니다. 먼저 0으로 채워진 매트릭스를 만들고 가장자리는 로봇이 움직이지 못 하도록 1로 채우겠습니다. n&lt;-8 maze &lt;- matrix(0, nrow=n, ncol=n) maze[1,] &lt;- 1 maze[n,] &lt;- 1 maze[,1] &lt;- 1 maze[,n] &lt;- 1 이제 중앙 공간에서 이동하지 못하는 곳을 랜덤하게 정해서 넣겠습니다. 넣는 방법은 아래와 같습니다. 수업시간에 2차원 매트릭스의 인덱싱을 1차원처럼 해도 된다고 말씀 드렸습니다. 대신 인덱스 번호는 왼쪽 위로부터 1부터 시작해서 아래로 증가하고 해당 column의 길이 끝까지 간 후 다시 오른쪽 column 상단에서부터 시작되어 이어지는 인덱스 번호를 갖게 됩니다. 아래는 1부터 64까지 (가로 세로 8칸 이므로 64개) 인덱스 중 10개를 랜덤하게 뽑아서 해당 인덱스 자리의 값을 1로 채우는 코드 입니다. 앞서 가장자리를 1로 채운 곳과 겹치더라도 상관 없습니다. maze[sample(1:64,10)] &lt;- 1 maze ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 1 1 1 1 1 1 1 ## [2,] 1 0 0 0 0 1 0 1 ## [3,] 1 0 1 0 0 0 0 1 ## [4,] 1 0 0 0 1 0 0 1 ## [5,] 1 0 1 1 0 0 1 1 ## [6,] 1 0 0 0 0 0 0 1 ## [7,] 1 0 0 0 1 0 0 1 ## [8,] 1 1 1 1 1 1 1 1 이제 위 코드를 활용해서 maze matrix 맵을 만드는 함수인 generate_maze 를 작성해 봅니다. 입력 파라메터는 n 하나로 가로 또는 세로의 (정사각형) 갯수를 의미합니다. generate_maze &lt;- function(n){ maze &lt;- matrix(0, nrow=n, ncol=n) maze[1,] &lt;- 1 maze[n,] &lt;- 1 maze[,1] &lt;- 1 maze[,n] &lt;- 1 ## blocks maze[sample(1:(n*n),5)] &lt;- 1 maze } mymaze &lt;- generate_maze(8) mymaze ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 1 1 1 1 1 1 1 ## [2,] 1 0 0 0 0 0 1 1 ## [3,] 1 0 0 0 0 0 1 1 ## [4,] 1 0 0 0 0 1 0 1 ## [5,] 1 0 0 0 0 0 0 1 ## [6,] 1 0 0 0 0 0 0 1 ## [7,] 1 0 0 0 0 0 0 1 ## [8,] 1 1 1 1 1 1 1 1 5.6 Draw blocks and walls 이제 위에서 생성된 매트릭스를 기반으로 로봇이 가지 못하는 길을 사각형으로 그려넣어 맵을 완성합니다. 매트릭스가 8x8 일 경우 64개 포인트의 모든 값들을 비교하여 1일 경우 사각형을 그리는 코드를 만들면 되겠습니다. 이 때 값을 비교하기 위해 if 문을 사용할 수 있고 해당 값들을 비교하기 위해 아래와 같은 코드를 작성할 수 있습니다. if(mymaze[1,1]==1){ ## plot square } if(mymaze[1,2]==1){ ## plot square } if(mymaze[1,3]==1){ ## plot square } ... if(mymaze[2,1]==1){ ## plot square } if(mymaze[2,2]==1){ ## plot square } if(mymaze[2,3]==1){ ## plot square } ... 그러나 이런식으로 64개 값들을 모두 비교하는 것은 비효율적입니다. mymaze 매트릭스의 인덱스 번호가 row와 column각각 1부터 8까지 증가하는 것으로 보면 앞에서 배웠던 for 문을 사용해서 좀 더 효율적인 코드를 만들 수 있을 듯 합니다. 아래 코드에서 nrow와 ncol은 각각 해당 매트릭스의 행과 열의 갯수를 계산해 주는 함수들 입니다. 즉, for 문을 이용하여 row 만큼 반복하고 다시 그 안에서 for문을 한 번 더 사용하여 column 수만큼 반복을 하면 해당 매트릭스의 모든 값들을 참조할 수 있습니다. 아래는 mymaze[i,j]가 1일 경우 points 문을 이용하여 pch=22 인 모양을 cex=3 크기로 bg=“gray” 색으로 칠하는 코드입니다. draw_world(cur_x, cur_y) for(i in 1:nrow(mymaze)){ for(j in 1:nrow(mymaze)){ if(mymaze[i,j]==1){ points(i,j, pch=22, cex=3, bg=&quot;gray&quot;) } } } 이제 위 코드를 앞서 만들었던 draw_world 함수에 추가하여 draw_world 함수를 호출할 경우 완전한 맵과 적당한 위치의 로봇을 그려주도록 할 수 있습니다. 그런데 맵 정보는 generate_maze 함수로 생성한 매트릭스가 가지고 있으므로 생성된 맵의 정보를 draw_world 함수 내부에서 사용할 수 있도록 파라메터로 전달해서 넘겨주는 것이 필요합니다. 따라서 maze라는 파라메터를 draw_world 함수에 추가하고 함수 내부에 있던 n 값은 입력받은 매트릭스의 row 또는 column 수를 저장하도록 n &lt;- nrow(maze) 코드를 추가합니다. draw_world &lt;- function(maze, cur_x, cur_y){ n &lt;- nrow(maze) plot(0, type=&quot;n&quot;, ylim=c(1,n), xlim=c(1,n)) for(i in 1:n){ lines(x=c(i,i), y=c(1,n)) lines(x=c(1,n), y=c(i,i)) } for(i in 1:nrow(maze)){ for(j in 1:nrow(maze)){ if(maze[i,j]==1){ points(i,j, pch=22, cex=3, bg=&quot;gray&quot;) } } } points(x=cur_x, y=cur_y, pch=16, cex=3) } 이제 8 x 8 맵을 생성하고 랜덤하게 길을 막은 후 로봇을 x=2, y=2로 위치하게 한 완전한 지도를 그릴 수 있습니다. 참고로 여기서 draw_world 함수에서 maze 맵을 생성하도록 generate_maze에서 수행하는 코드와 비슷한 코드를 넣을 수 있습니다. 그러나 이럴 경우 한 함수에서 두 가지 이상의 작업을 수행하게 되므로 가독성, 함수 독립성, 유지보수 용이성이 낮아지면서 프로그램의 효율성이 떨어질 수 있습니다. cur_x &lt;- 2 cur_y &lt;- 2 mymaze &lt;- generate_maze(8) draw_world(mymaze, cur_x, cur_y) 5.7 Move one step 이제 로봇이 한 걸음을 옮기는 코드를 작성해 보겠습니다. 로봇은 현재 위치에서 4개의 방향으로 갈 수 있으나 이 중 막힌 길로는 갈 수 없습니다. 즉 현재 위치에서 동,서,남,북 중 하나의 방향을 랜덤하게 정하고 그 방향으로 한 걸음을 움직인 곳의 지도(매트릭스)상의 값이 0이면 이동한 위치 그대로 있고 1이면 다시 왔던 자리로 돌아가면 됩니다. next_x와 next_y를 cur_x, cur_y의 한 걸음 이후 위치라 정의하면 아래와 같이 정해진 방향으로 업데이트 한 후 next_x, next_y 위치에서 draw_world를 수행하면 됩니다. cur_x &lt;- 2 cur_y &lt;- 2 draw_world(mymaze, cur_x, cur_y) one_step_direction &lt;- sample(c(&quot;E&quot;,&quot;W&quot;, &quot;S&quot;, &quot;N&quot;), 1) if(one_step_direction==&quot;E&quot;){ next_x &lt;- cur_x + 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;W&quot;){ next_x &lt;- cur_x - 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;S&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y - 1 }else if(one_step_direction==&quot;N&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y + 1 } draw_world(mymaze, next_x, next_y) 5.8 Sleep for delay 그러나 위 코드를 실행하면 cur_x, cur_y 위치에 있을 때 그림은 보여지지 않고 마지막 next_x, next_y 위치 로봇에 대해서만 그림이 그려져 보이는 것을 알 수 있습니다. 이는 코드 문제라기 보다는 컴퓨터 반응시간 문제로 그림이 그려지기 전에 다른 그림이 그려지는 문제로 나타나는 현상 입니다. 따라서 Sys.sleep(1) 이라는 명령어로 1초 동안 코드 실행을 멈출 수 있고 그 동안 우리는 cur_x, cur_y 위치의 로봇이 그려지는 것을 볼 수 있습니다. 또한 위 코드는 지도상의 어디든 갈 수 있는 상태로 막힌 곳의 위치로는 움직이지 못 하도록 하는 코드가 필요합니다. 이를 위해 다음 마지막 부분의 if문처럼 코드를 업데이트하여 next_x, next_y 위치가 0일 경우에만 draw_world를 호출하여 그림을 업데이트 하고 그렇지 않으면 아무 일도 하지 않게 합니다. cur_x &lt;- 2 cur_y &lt;- 2 draw_world(mymaze, cur_x, cur_y) Sys.sleep(1) one_step_direction &lt;- sample(c(&quot;E&quot;,&quot;W&quot;, &quot;S&quot;, &quot;N&quot;), 1) if(one_step_direction==&quot;E&quot;){ next_x &lt;- cur_x + 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;W&quot;){ next_x &lt;- cur_x - 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;S&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y - 1 }else if(one_step_direction==&quot;N&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y + 1 } if(mymaze[next_x, next_y]==0){ draw_world(mymaze, next_x, next_y) } 5.9 Move 50 steps 이제 for 문을 이용해서 50 step 이동하는 것을 구현해 보겠습니다. 여기서 눈여겨 볼 부분은 마지막 next_x 와 next_y의 위치에 0일 경우 draw_world를 호출하지 않고 cur_x, cur_y 값을 업데이트 시켜서 효율적으로 구현했습니다. mymaze &lt;- generate_maze(8) cur_x &lt;- 2 cur_y &lt;- 2 for(i in 1:50){ draw_world(mymaze, cur_x, cur_y) Sys.sleep(1) one_step_direction &lt;- sample(c(&quot;E&quot;,&quot;W&quot;, &quot;S&quot;, &quot;N&quot;), 1) cat(i, &quot;/&quot;, one_step_direction, &quot;\\n&quot;);flush.console() if(one_step_direction==&quot;E&quot;){ next_x &lt;- cur_x + 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;W&quot;){ next_x &lt;- cur_x - 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;S&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y - 1 }else if(one_step_direction==&quot;N&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y + 1 } if(mymaze[next_x, next_y]==0){ cur_x &lt;- next_x cur_y &lt;- next_y } } "],
["lecture-05-multiple-plate-reader-file.html", "6 Lecture 05 - Multiple plate reader file 6.1 File I/O 파일 입출력 6.2 plot 산포도 6.3 hist 히스토그램 6.4 boxplot 상자그래프 6.5 barplot 막대그래프 6.6 other examples 그래프 예시 6.7 Multiplate reader 기능 구현 6.8 Multiplate reader function 만들기", " 6 Lecture 05 - Multiple plate reader file 강의노트와 실습용 엑셀파일은 다음을 참고 하세요 Lecture note design excel file data excel file 이번 시간에는 R에서 제공하는 기본 그래프 함수들을 간략하게 알아보고 지난 3번째 강의에서 간략하게 실습했던 multiple plate reader (\\(Victor^{TM}\\), PerkinElmer, Inc.) 장비를 통해 측정된 데이터를 읽어와서 분석하기 위한 함수를 작성해 보겠습니다. 생물학 실험에서 샘플의 실험 조건이 다양하게 달라지고 96 well plate상에서 측정된 위치 등이 수시로 바뀌는 등의 상황에 의존적이지 않고 해당 장비를 사용할 경우에 한해서는 일반적으로 사용할 수 있는 함수를 만드는 것이 목표 입니다. 6.1 File I/O 파일 입출력 먼저 지난 시간에 배웠던 파일 입출력 코드를 보겠습니다. write.table 함수는 택스트 파일로 해당 데이터를 저장합니다. ?write.table 도움말을 보시면 quote=TRUE로 모든 값들을 따옴표가 있는 문자로 저장합니다. 따라서 숫자형으로 저장하기 위해서는 quote=F를 명시해야 하며 read.table은 테이블 형태로 파일 내용을 읽어오며 반환되는 오브젝트 타입은 기본적으로 data.frame 입니다. x1 &lt;- c(1,2,5,7) y1 &lt;- c(1,6,7,8) xy&lt;-data.frame(x1, y1) write.table(xy, file=&quot;table_write.txt&quot;, quote=F) myxy &lt;- read.table(file=&quot;table_write.txt&quot;) myxy ## x1 y1 ## 1 1 1 ## 2 2 6 ## 3 5 7 ## 4 7 8 class(myxy) ## [1] &quot;data.frame&quot; names(myxy) ## [1] &quot;x1&quot; &quot;y1&quot; 6.2 plot 산포도 R에서 plot 함수는 가장 기본이 되는 그래프 함수 입니다. 아래는 산포도를 그려주는 코드로서 myxy가 두 개의 변수(x1과 y1)를 가지고 있으므로 아래 명령들은 모두 같은 그림을 그려주게 됩니다. 가장 마지막 명령은 formula를 사용한 plot으로 첫번째 파라메터 인자로 formula 타입이 전달되면 plot.formula 함수가 실행되며 x, y 값이 전달될 경우 plot.default 함수가 수행됩니다. R에서는 이렇게 전달되는 파라메터의 타입에 따라서 다른 기능을 하는 함수를 Generic function 이라고 합니다. plot(myxy) plot(myxy$x1, myxy$y1) plot(x=myxy$x1, y=myxy$y1) plot(y1~x1, data=myxy) 6.3 hist 히스토그램 hist는 데이터들의 분포를 히스토그램으로 그려주는 함수입니다. 히스토그램은 데이터들이 갖는 값을 특정 구간으로 나누고 각 구간에 해당하는 데이터가 몇 개인지 빈도수를 계산하여 막대그래프로 보여주는 함수 입니다. x &lt;- rnorm(100) hist(x, br=20, xlim=c(-3,3), main=&quot;Main text&quot;, xlab=&quot;X label&quot;) 6.4 boxplot 상자그래프 boxplot은 데이터의 여러가지 대표값 (중간값 median, 첫번째 사분위수 1st quantile, 세번째 사분위수 3rd quantile, 최소 minimum, 최대값 maximum) 등을 한눈에 볼 수 있도록 만들어놓은 그래프 입니다. boxplot(x) data.frame 타입의 오브젝트에 대해서 boxplot을 그릴 경우 여러 변수의 데이터들의 분포를 한눈에 비교할 수 있읍니다. y &lt;- rnorm(100, 1, 1) #boxplot(y) xy &lt;- data.frame(x, y) boxplot(xy) class(xy) ## [1] &quot;data.frame&quot; 6.5 barplot 막대그래프 막대그래프는 기존 수업에서도 실습을 진행한 그래프로 각 값들을 막대 형태로 나란히 배치하여 서로 비교가 용이하도록 만든 그래프 입니다. table 함수는 같은 값을 갖는 데이터들이 몇 개나 있는지 테이블을 만들어주는 함수 입니다. rbind는 두 변수를 row를 기준으로 붙여주는 역할의 함수입니다. x &lt;- sample(1:12, 200, replace = T) tab_x &lt;- table(x) y &lt;- sample(1:12, 200, replace = T) tab_y &lt;- table(y) tab_xy &lt;- rbind(tab_x, tab_y) #barplot(tab_xy) #barplot(tab_xy, beside = T) #barplot(tab_xy, beside = T, col=c(&quot;darkblue&quot;,&quot;red&quot;)) barplot(tab_xy, beside = T, col=c(&quot;darkblue&quot;,&quot;red&quot;), xlab=&quot;Month&quot;) barplot(tab_xy, beside = T, col=c(&quot;darkblue&quot;,&quot;red&quot;), xlab=&quot;Month&quot;, horiz=TRUE) 6.6 other examples 그래프 예시 위 예제들에서 사용한 high level function들을 low level function (lines, points, ablines, axis 등)들과 함께 사용함으로써 원하는 도표 대부분을 그려낼 수 있습니다. 최근 널리 사용되는 ggplot2 패키지를 이용한 그래프 사용법 강의에서는 오늘 배우는 그래픽 명령어는 거의 사용하지 않습니다. 그러나 위 함수들은 R의 기본 그래프 함수들로서 단순한 도표에서부터 복잡한 그래픽까지 구현할 수 있는 다양한 유연성을 제공하므로 기본적인 사용법을 정확히 이해하는 것이 필수입니다. 아래 도표는 평균 0, 분산 1인 분포에서 500개의 랜덤한 수를 뽑아 x에 저장하고 x의 분포를 히스토그램으로 표현한 것 입니다. x &lt;- rnorm(500) hist(x, 100) 아래는 앞서 생성한 x 값들과 상관성이 있는 y값들을 (x에 2를 곱하고 평균 5, 분산 1인 랜덤하게 뽑힌 수를 노이즈로 더함) 생성하고 모든 1000개 값들의 분포를 그린 히스토그램 입니다. 또한 density 함수와 lines 함수를 조합하여 확률밀도함수 커브를 그려 넣었습니다. 이 때 hist 함수에 probability=T 옵션을 넣어 y축의 스케일을 확률밀도함수의 y 스케일과 맞춰주어 같은 화면에 그려지도록 했습니다. y &lt;- 2*x + rnorm(500, mean=5, sd=1) z &lt;- c(x,y) hist(z, br=100, probability = T) lines(density(z)) 위에서 생성한 x, y 값의 산포도를 그리고 x축과 y축 범위를 xlim, ylim 파라메터로 조절했습니다. ?pch 도움말을 참고하여 다양한 포인트 모양을 선택할 수 있으며 x 값이 0 보다 작은 경우의 index를 뽑아 해당되는 x 값들과 그 값들의 짝이 되는 y값들에 대해서만 다시 포인트 그림을 red 색상으로 그려 넣었습니다. lm 은 linear model의 약자로 회귀 곡선을 구할 때 사용하는 함수이며 이 함수를 abline과 조합하여 회귀 직선을 그릴 수 있습니다. plot(x,y, xlim=c(-5, 5), ylim=c(-5, 15), pch=3) idx &lt;- which(x&lt;0) points(x[idx], y[idx], col=&quot;red&quot;) abline(lm(y~x)) 6.7 Multiplate reader 기능 구현 함수를 만들기 위한 프로그래밍 소개 및 전략 등의 내용은 강의노트를 참고하시기 바랍니다. 특히 exp_design.xlsx 파일은 실험 후 결과 측정을 위하여 96 well plate에 위치할 샘플들의 위치 및 실험 조건을 명시해둔 파일로서 이번 시간 만드는 함수의 핵심이 되는 파일입니다. 일반적으로 R에서 함수를 만들기 전에 해당 함수가 가진 기능들을 한줄 한줄 먼저 구현해서 확인한 후 함수 형태로 만들어 내는 것이 좋습니다. 먼저 excel 파일을 읽어오기 위하여 readxl 패키지를 불러온 후 read_excel 함수의 range 파라메터를 이용하여 96 well plate의 dimension과 같은 8 x 12 데이터를 모두 읽습니다. read_excel 함수는 기본적으로 tibble 형식의 데이터를 반환하지만 본 강의에서는 data.frame 형식으로 사용하기 위하여 as.data.frame 함수를 이용하여 변환을 해 줍니다. 참고로 최근 R을 이용한 데이터 분석에는 tibble 타입이 많이 쓰이는 추세입니다. #options(readxl.show_progress = FALSE) library(readxl) design_file_name &lt;- &quot;exp_design.xlsx&quot; data_file_name &lt;- &quot;Rprog04-fl.xls&quot; #mydesign &lt;- read_excel(design_file_name, sheet=1) mydesign &lt;- as.data.frame(read_excel(design_file_name, sheet=1, range=&quot;A1:L8&quot;, skip = 0, col_names=F)) mydata &lt;- as.data.frame(read_excel(data_file_name, sheet=1)) #head(mydesign) #head(mydata) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems ## New names: ## * Time -&gt; Time...5 ## * Time -&gt; Time...7 위 design 엑셀 파일로 샘플이 놓인 위치와 그 실험 조건을 읽어올 수 있으나 data를 뽑아올 수 있는 well의 이름인 (mydata 데이터 확인) A01, A02, …, B01, B02와 같은 이름 정보는 존재하지 않습니다. 이에 96 well plate 와 동일한 크기의 메트릭스를 만들고 각 셀에 well 이름들로 값을 넣어 추후 인덱스를 얻었을 때 그 위치에 해당하는 well 이름을 얻을 수 있도록 합니다. sprintf는 %02d와 같이 명시한 포맷으로 숫자를 출력해주는 함수 입니다. %02d는 digit 2자리 포맷을 가리키는 문자열로 한자리 숫자의 경우 앞에 0을 넣어 2자리로 만들어 출력해 줍니다. # make a position matrix pos1 &lt;- rep(LETTERS[1:8], time=12) pos2 &lt;- rep(sprintf(&quot;%02d&quot;, 1:12), each=8) well_position_labels &lt;- paste(pos1, pos2, sep=&quot;&quot;) well_position_matrix &lt;- matrix(well_position_labels, nrow=8, ncol=12) 이제 design 메트릭스에서 실험 조건이 명시된 위치의 well 이름을 꺼내오는 작업을 수행합니다. 이 때 바로 matrix에 대해서 코딩을 하기 보다는 vector 수준에서 값을 불러오는 코드를 먼저 만들고 matrix로 확장하는 것이 좋습니다. 아래는 첫 번째 컬럼의 값들에 대해서만 (vector 수준에서) 값을 추출하는 코드입니다. is.na는 해당 값이 NA인지 검사해서 NA일 경우 TRUE를 그렇지 않으면 FALSE를 리턴해주는 함수 입니다. ## vector tmpi &lt;- mydesign[, 1] tmpv &lt;- well_position_matrix[, 1] !is.na(tmpi) which(!is.na(tmpi)) tmpi[!is.na(tmpi)] tmpv[!is.na(tmpi)] 이제 위 코드를 함수로 만들고 lapply 함수를 사용하여 data.frame에 적용하도록 합니다. 함수는 다음 두 개의 함수(extract_values, extract_values2)로서 extract_value 함수는 입력되는 파라메터 벡터 x에서 na 가 아닌 값들을 추출하는 함수입니다. extract_value2는 다른 두 개의 메트리스를 파라메터로 넘겨서 값을 뽑기 위한 변형된 함수로 입력되는 파라메터 x가 16개의 값을 가지며 1부터 8까지 8개의 값들 중 na 가 아닌 인덱스를 뽑아내고 실제 값은 9부터 16까지의 8개 값들 중 해당하는 인덱스의 값을 뽑아내는 함수 입니다. extract_values &lt;- function(x){ index &lt;- which(!is.na(x)) return(x[index]) } #extract_values(tmpi) extract_values2 &lt;- function(x){ conditions &lt;- x[1:8] well_names &lt;- x[9:16] index &lt;- which(!is.na(conditions)) return(well_names[index]) } #extract_values2(c(tmpi, tmpv)) 이제 위 함수들, 특히extract_value2 함수을 이용해서 well 이름을 추출하기 위해서 mydesign과 well_position_matrix 두 메트릭스를 bind한 bound_matrix라는 메트릭스를 만들고 lapply로 extract_value 함수와 extract_value2 함수를 사용하여 well 이름과 well_condition을 각각 뽑아 냅니다. 마지막 well_info data.frame은 두 변수를 묶어놓은 것으로 data.frame 생성시 문자형이 factor형으로 자동 형 변환 되는 것을 막기 위하여 stingAsFactors = F 옵션을 추가해 줍니다. colnames(mydesign) &lt;- as.character(1:12) colnames(well_position_matrix) &lt;- as.character(1:12) bound_matrix &lt;- rbind(mydesign, well_position_matrix) tmpv &lt;- lapply(bound_matrix, extract_values2) well_names &lt;- unlist(tmpv) tmpv &lt;- lapply(mydesign, extract_values) well_conditions &lt;- unlist(tmpv) well_info &lt;- data.frame(well_names, well_conditions, stringsAsFactors = F) well_info에 명시된 well 이름에 해당하는 데이터를 mydata에서 추출하기 위해 match 함수를 사용합니다. match 함수는 두 개의 벡터에서 공통되는 값을 가진 인덱스를 뽑기 위한 함수 입니다. #dim(mydata) head(mydata) ## Plate Repeat Well Type Time...5 595nm_kk (A) Time...7 ## 1 1 1 B01 M 0.0001843750 0.7012086 0.0008273148 ## 2 1 1 B02 M 0.0001888889 0.7518509 0.0008320602 ## 3 1 1 B03 M 0.0001931713 0.7232866 0.0008368056 ## 4 1 1 B04 M 0.0001974537 0.7440926 0.0008415509 ## 5 1 1 B05 M 0.0002017361 0.7056004 0.0008462963 ## 6 1 1 B06 M 0.0002060185 0.7228400 0.0008510417 ## EGFP_sulim (Counts) ## 1 67809 ## 2 60025 ## 3 102745 ## 4 99979 ## 5 108175 ## 6 109575 head(well_info) ## well_names well_conditions ## 11 B01 1;1;0 ## 12 C01 1;2;0 ## 13 D01 2;1;0 ## 14 E01 2;2;0 ## 21 B02 1;1;10 ## 22 C02 1;2;10 mydata에는 well 이라는 변수에 well_info에는 well_names라는 변수에 우리가 비교하고자 하는 값들이 들어 있습니다. match 함수의 리턴 값은 첫번째 파라메터로 넘겨진 변수를 기준으로 해당 값들이 두 번째 파라메터 변수의 값에 해당하는 인덱스 입니다. 쉽게 혼동될 수 있으니 꼭 help를 참고해서 명확히 이해하시길 바랍니다. mydata에서 데이터를 뽑아야 하므로 아래처럼 well_info에 존재하는지 검사하고 존재하는 값들만 subset 함수를 사용해서 뽑아냅니다. # match(mydata$Well, well_info$well_names) tmpidx &lt;- match(mydata$Well, well_info$well_names) tmp_mydata_subset &lt;- subset(mydata, !is.na(tmpidx)) head(tmp_mydata_subset) ## Plate Repeat Well Type Time...5 595nm_kk (A) Time...7 ## 1 1 1 B01 M 0.0001843750 0.7012086 0.0008273148 ## 2 1 1 B02 M 0.0001888889 0.7518509 0.0008320602 ## 3 1 1 B03 M 0.0001931713 0.7232866 0.0008368056 ## 4 1 1 B04 M 0.0001974537 0.7440926 0.0008415509 ## 13 1 1 C01 M 0.0002644676 0.8026616 0.0009127315 ## 14 1 1 C02 M 0.0002687500 0.7750938 0.0009174769 ## EGFP_sulim (Counts) ## 1 67809 ## 2 60025 ## 3 102745 ## 4 99979 ## 13 42654 ## 14 33957 위 tmp_mydata_subset에서 우리가 필요한 정보는 well 이름과 OD, 형광값으로 각각 3번째 6번째 8번째 컬럼에 들어있습니다. 그러나 실험에서 OD 만 찍을 경우 8번째 컬럼은 존재하지 않게 됩니다. 즉, 이 부분이 실험 조건에 따라서 에러가 발생될 수 있는 부분이라 좀 더 일반적으로 사용 가능한 함수를 구현하기 위해서는 이 부분을 개선해줄 필요가 있습니다. OD, green 형광, red 형광을 측정할 경우 3, 6, 8, 10 번째 컬럼 순으로 데이터가 저장될 수 있습니다. 따라서 tmp_mydata_subset 의 컬럼 길이보다 작은 짝수만큼 컬럼을 선택하면되고 다음과 같이 간단히 코드를 작성할 수 있습니다 (3은 필수, 최소 하나의 데이터를 찍으면 6번째 컬럼에 들어가므로 시작은 6부터). sel_column &lt;- c(3, seq(6, ncol(tmp_mydata_subset), by=2)) mydata_subset &lt;- tmp_mydata_subset[,sel_column] head(mydata_subset) ## Well 595nm_kk (A) EGFP_sulim (Counts) ## 1 B01 0.7012086 67809 ## 2 B02 0.7518509 60025 ## 3 B03 0.7232866 102745 ## 4 B04 0.7440926 99979 ## 13 C01 0.8026616 42654 ## 14 C02 0.7750938 33957 이제 well_info와 mydata_subset을 하나의 data.frame으로 합하겠습니다. 하나의 오브젝트로 구성하는 것이 추후 그래프 작성이나 분석을 위해서 편리하기 때문입니다. merge라는 함수는 두 데이터셋을 각각 공통으로 가진 변수를 기준으로 합해주는 함수입니다. 단순히 cbind 등으로 두 데이터프레임을 붙여 놓을 경우 각각의 데이터 정렬 순서가 다르기 때문에 하나의 row에 다른 정보가 섞이게 됩니다. 따라서 두 데이터셋을 붙일 경우 위와 같이 공통되는 변수를 기준으로 적절히 정렬 후 붙이는 것이 필수입니다. 아래 코드의 by.x는 첫번째 파라메터로 넘겨진 오브젝트가 갖는 공통된 변수 이름이며 두번째 by.y는 두번째 파라메터로 넘겨진 오브젝트가 갖는 공통된 변수 이름 입니다. final_data &lt;- merge(well_info, mydata_subset, by.x=&quot;well_names&quot;, by.y=&quot;Well&quot;) head(final_data) ## well_names well_conditions 595nm_kk (A) EGFP_sulim (Counts) ## 1 B01 1;1;0 0.7012086 67809 ## 2 B02 1;1;10 0.7518509 60025 ## 3 B03 1;1;100 0.7232866 102745 ## 4 B04 1;1;1000 0.7440926 99979 ## 5 C01 1;2;0 0.8026616 42654 ## 6 C02 1;2;10 0.7750938 33957 이제 목적했던 함수를 만들기 전 마지막 단계로 실험 조건을 좀 더 보기 쉽게 바꿔보도록 하겠습니다. 위 데이터에 보시면 well_conditions 변수에 세 개의 실험 조건이 “;”으로 붙어 표현되어 있습니다. 각각 샘플이름, 반복횟수, 약품농도 입니다. 아래 strsplit 함수는 split에 명시된 문자를 기준으로 첫번째 파라메터 문자를 나누어 주는 기능을 수행합니다. 아래처럼 벡터연산이 가능하여 한번에 모든 컨디션 정보를 나누어 줄 수도 있습니다. 리턴값 형태는 리스트로서 unlist를 통해 벡터로 전환 가능 합니다. ## strsplit(&quot;1;1;0&quot;, split=&quot;;&quot;) ## unlist(strsplit(&quot;1;1;0&quot;, &quot;;&quot;)) tmp &lt;- strsplit(final_data$well_conditions, &quot;;&quot;) head(tmp) ## [[1]] ## [1] &quot;1&quot; &quot;1&quot; &quot;0&quot; ## ## [[2]] ## [1] &quot;1&quot; &quot;1&quot; &quot;10&quot; ## ## [[3]] ## [1] &quot;1&quot; &quot;1&quot; &quot;100&quot; ## ## [[4]] ## [1] &quot;1&quot; &quot;1&quot; &quot;1000&quot; ## ## [[5]] ## [1] &quot;1&quot; &quot;2&quot; &quot;0&quot; ## ## [[6]] ## [1] &quot;1&quot; &quot;2&quot; &quot;10&quot; 그런데 위와 같이 벡터연산을 수행하여 정보를 추출할 경우 목적하는 바에 따라서 불편한 점도 있습니다. 본 강의에서는 아래와 같이 하나의 백터로 조건 정보를 입력받아 값을 쪼갠 후 이름을 붙여주는 함수를 만들고 이를 apply 함수와 비슷한 기능의 sapply를 적용하도록 하겠습니다. sapply의 차이점은 help를 참고하세요. myparse &lt;- function(x){ tmp &lt;- unlist(strsplit(x, &quot;;&quot;)) names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;concentration&quot;) return(tmp) } tmpcond &lt;- sapply(final_data$well_conditions, myparse) head(tmpcond) ## 1;1;0 1;1;10 1;1;100 1;1;1000 1;2;0 1;2;10 1;2;100 1;2;1000 ## sample_names &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; ## replication &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; ## concentration &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; ## 2;1;0 2;1;10 2;1;100 2;1;1000 2;2;0 2;2;10 2;2;100 2;2;1000 ## sample_names &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; ## replication &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; ## concentration &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; 각각 쪼개서 이름을 붙이는 작업 후 리턴된 결과를 보니 3 x 16 matrix 입니다. 앞서 우리가 구한 final_data와 나란히 붙여 넣기 위해서 t라는 함수를 사용하여 행과 열을 교환하는 transformation 을 수행합니다. 이제 merge 함수를 사용하여 붙여 넣어야 하는데 t_tmpcond 행렬에는 final_data와 같은 정보를 갖는 변수가 없습니다. 따라서 final_data의 well_conditions 와 같은 정보를 갖는 t_tmpcond의 rowname을 하나의 변수로 추가해 준 후 해당 공통 정보를 갖는 변수를 기준으로 두 오브젝트를 merge 해 줍니다. 마지막으로 well_conditions 정보는 중복이므로 제거해 주는 작업을 수행합니다. t_tmpcond &lt;- t(sapply(final_data$well_conditions, myparse)) t_tmpcond2 &lt;- cbind(t_tmpcond, rownames(t_tmpcond)) t_tmpcond2 &lt;- cbind(t_tmpcond, well_conditions=rownames(t_tmpcond)) final_data &lt;- merge(final_data, t_tmpcond2, by=&quot;well_conditions&quot;) final_data &lt;- final_data[,-1] head(final_data) ## well_names 595nm_kk (A) EGFP_sulim (Counts) sample_names replication ## 1 B01 0.7012086 67809 1 1 ## 2 B02 0.7518509 60025 1 1 ## 3 B03 0.7232866 102745 1 1 ## 4 B04 0.7440926 99979 1 1 ## 5 C01 0.8026616 42654 1 2 ## 6 C02 0.7750938 33957 1 2 ## concentration ## 1 0 ## 2 10 ## 3 100 ## 4 1000 ## 5 0 ## 6 10 6.8 Multiplate reader function 만들기 지금까지 수행한 코드들로 다음과 같은 함수를 만들 수 있습니다. read_multiplate_data &lt;- function(file_names){ design_file_name &lt;- file_names[1] data_file_name &lt;- file_names[2] # .... # .... code for the function ... # .... do it yourself ... # .... return(final_data) } 그리고 다음과 같이 엑셀 파일 이름만 넣어주면 원하는 데이터가 정리되어 나오게 됩니다. multiplate_file_names &lt;- c(&quot;exp_design.xlsx&quot;, &quot;Rprog04-fl.xls&quot;) myfinal_data &lt;- read_multiplate_data(multiplate_file_names) 함수의 기능은 앞서 설명드린 코드들로 대부분 구현 가능합니다. 물론 조금씩 더 신경쓸 부분이 있을 수 있으나 큰 오류는 없을 것으로 생각되며 구현중에 어려운 부분은 수업시간에 질문해 주시면 되겠습니다. "],
["lecture-06-multiple-plate-reader-ggplot.html", "7 Lecture 06 - Multiple plate reader / ggplot 7.1 multiple_plate_excel_reader 함수 만들기 7.2 multiple_plate_excel_reader2 함수 업데이트 7.3 Read data 7.4 ggplot 이용 barplot 그리기", " 7 Lecture 06 - Multiple plate reader / ggplot 실습용 엑셀파을 먼저 download 하세요 design excel file 2 data excel file 1 data excel file 2 data excel file 3 data excel file 4 R function for plate read 강의 노트 Lecture note 이번 시간에는 지난시간에 이어서 multiple plate reader에 의해서 측정되고 엑셀에 저장된 데이터를 읽어오는 함수를 마무리하고 해당 함수를 사용하여 여러 파일들을 읽어오는 실습을 하겠습니다. 후반부에서는 읽어들인 데이터를 ggplot 패키지를 사용하여 간단한 barplot을 그려보는 것으로 강의는 마무리 하겠습니다. 강의시간에 말씀 드렸지만 오늘 만드는 함수대한 세부적인 내용을 모두 이해하실 필요는 없습니다. 다만 지금 만들고있는 함수를 왜 만들고 어떻게 사용하는지를 아는 것은 중요합니다. 프로그래밍의 대부분은 함수와 로직을 만드는데 있고 R을 이용한 데이터 분석 또한 함수를 사용하면서 대부분의 시간을 보내기 때문에 함수를 왜 만들고 사용하는지를 이해하는 것은 중요합니다. 7.1 multiple_plate_excel_reader 함수 만들기 먼저 처음 만드는 함수는 다음과 같이 만들어지고 쓰일 것 입니다. 함수의 이름은 multiple_plate_excel_reader 이고 입력 파라메터의 갯수는 두 개입니다. design file과 data file 이름들 입니다. multiple_plate_excel_reader &lt;- function(design_file_name, data_file_name){ ### ### code ### } design_file_name &lt;- &quot;exp_design.xlsx&quot; data_file_name &lt;- &quot;Rprog04-fl.xls&quot; mydata &lt;- multiple_plate_excel_read(design_file_name, data_file_name) 이제 함수를 만들기 위해 read_plate.R 이라는 파일을 만들고 다음처럼 코드를 작성합니다. 간단한 기능을 하는 짧은 라인의 함수의 경우 바로 함수를 작성해도 괜찮습니다. 그러나 지금과 같이 비교적 긴 라인의 함수는 파라메터로 입력되는 값들을 미리 정의해 놓고 함수 선언문 이후의 코드들을 하나하나 실행하면서 작동을 확인 합니다. 그 후 마지막에 함수 선언문을 작성하고 블럭으로 묶어놓는 방식으로 함수를 작성합니다. 아래의 경우는 함수가 선언되는 부분을 주석으로 처리해 두었습니다. require 명령은 library와 같은 기능입니다. 그리고 read_excel 함수를 사용해서 엑셀 파일들을 불러오는 부분입니다. 최근에는 tibble 형태의 오브젝트를 많이 쓰지만 여기서는 기존 data.frame 오브젝트로 읽어오기 위해서 앞에 as.data.frame을 붙였습니다. design_file_name &lt;- &quot;exp_design.xlsx&quot; data_file_name &lt;- &quot;Rprog04-fl.xls&quot; #multiple_plate_excel_reader &lt;- function(design_file_name, data_file_name){ require(readxl) ## read excel files mydesign &lt;- as.data.frame(read_excel(design_file_name, sheet=1, range=&quot;A1:L8&quot;, skip = 0, col_names=F)) mydata &lt;- as.data.frame(read_excel(data_file_name, sheet=1)) #...code 이후 코드들은 모두 지난 시간 강의를 보시면 자세한 설명이 나와 있으니 생략하도록 하겠습니다. 아래는 완성된 함수의 전체 코드입니다. 마지막 부분에 rownames(t_tmpcond2) &lt;- NULL 코드가 지난번과 다르지만 이 부분은 row이름이 바뀌는 것을 막기 위해서 넣어주었습니다. multiple_plate_excel_reader &lt;- function(design_file_name, data_file_name){ require(readxl) ## read excel files mydesign &lt;- as.data.frame(read_excel(design_file_name, sheet=1, range=&quot;A1:L8&quot;, skip = 0, col_names=F)) mydata &lt;- as.data.frame(read_excel(data_file_name, sheet=1)) ## build a position matrix pos1 &lt;- rep(LETTERS[1:8], time=12) pos2 &lt;- rep(sprintf(&quot;%02d&quot;, 1:12), each=8) well_position_labels &lt;- paste(pos1, pos2, sep=&quot;&quot;) well_position_matrix &lt;- matrix(well_position_labels, nrow=8, ncol=12) ## extract positions from position matrix by using design matrix indexes colnames(mydesign) &lt;- as.character(1:12) colnames(well_position_matrix) &lt;- as.character(1:12) bound_matrix &lt;- rbind(mydesign, well_position_matrix) tmpv &lt;- lapply(bound_matrix, extract_values_from_other_matrix) well_names &lt;- unlist(tmpv) ## extract conditions from design matrix by design matrix indexes tmpv &lt;- lapply(mydesign, extract_values_from_own_matrix) well_conditions &lt;- unlist(tmpv) ## build well_info matrix well_info &lt;- data.frame(well_names, well_conditions, stringsAsFactors = F) ## subset of the data filtered by the wells that we are interested in tmpidx &lt;- match(mydata$Well, well_info$well_names) tmp_mydata_subset &lt;- subset(mydata, !is.na(tmpidx)) ## extract OD, GFP, etc if there is any sel_column &lt;- c(3, seq(6, ncol(tmp_mydata_subset), by=2)) mydata_subset &lt;- tmp_mydata_subset[,sel_column] ## to make the condition column more readable tmp_final_data &lt;- merge(well_info, mydata_subset, by.x=&quot;well_names&quot;, by.y=&quot;Well&quot;) tmpcond &lt;- sapply(tmp_final_data$well_conditions, function(x){ tmp &lt;- unlist(strsplit(x, &quot;;&quot;)) names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;concentration&quot;) return(tmp) } ) ## make final data matrix t_tmpcond &lt;- t(tmpcond) t_tmpcond2 &lt;- cbind(t_tmpcond, well_conditions=rownames(t_tmpcond)) rownames(t_tmpcond2) &lt;- NULL t_tmpcond2 &lt;- data.frame(t_tmpcond2) t_tmpcond2$concentration &lt;- as.numeric(as.character(t_tmpcond2$concentration)) final_data &lt;- merge(tmp_final_data, t_tmpcond2, by=&quot;well_conditions&quot;) final_data &lt;- final_data[,-1] return(final_data) } 이제 함수를 사용해 보겠습니다. 현재 실행중인 working 디렉토리 안에 &quot;exp_design.xlsx&quot; &quot;Rprog04-fl.xls&quot; 이 두 파일을 넣고 아래와 같은 코드를 실행 합니다. 여기서 처음보는 명령이 source 입니다. 이 명령은 해당 R 파일의 내용을 실행시키는 것과 같습니다. 즉 방금 만든 함수를 read_plate.R 파일에 저장해 두었고 해당 함수를 사용하기 위해서 전체 함수를 ctrl+enter 로 실행시키지 않고 source(&quot;read_plate.R&quot;) 한 줄 실행하는 것 만으로도 해당 함수를 사용할 수 있습니다. source(&quot;read_plate.R&quot;) design_file_name &lt;- &quot;exp_design.xlsx&quot; data_file_name &lt;- &quot;Rprog04-fl.xls&quot; mydata &lt;- multiple_plate_excel_reader(design_file_name, data_file_name) head(mydata) ## well_names 595nm_kk (A) EGFP_sulim (Counts) sample_names replication ## 1 B01 0.7012086 67809 1 1 ## 2 B02 0.7518509 60025 1 1 ## 3 B03 0.7232866 102745 1 1 ## 4 B04 0.7440926 99979 1 1 ## 5 C01 0.8026616 42654 1 2 ## 6 C02 0.7750938 33957 1 2 ## concentration ## 1 0 ## 2 10 ## 3 100 ## 4 1000 ## 5 0 ## 6 10 7.2 multiple_plate_excel_reader2 함수 업데이트 여기까지만 해도 어느 정도는 대부분의 실험 데이터를 읽어올 수 있는 함수로 사용될 수 있습니다. 그러나 좀 더 편리한 함수를 위해서 업그레이드를 해 보겠습니다. 대략 세 가지의 문제점이 있으며 그 첫번째로 실험 컨디션을 3개만 사용하고 있는 부분입니다. drug 농도 앞에 drug 이름을 넣는 경우를 생각해서 함수를 업데이트 하겠습니다. 또한 design 파일을 매 실험마다 새로 만들지 않고 sheet를 활용하는 방법과 마지막으로 column 이름에 595가 들어갈 경우 OD로 GFP가 들어가면 GFP로 컬럼 이름을 자동으로 바뀌게 하는 코드를 작성해 보겠습니다. 컬럼 이름을 바꾸는 이유는 앞서 결과에 보이는 것 처럼 컬럼 이름이 595nm_kk (A) 이런식으로 주어질 경우 indexing 하기 힘들기 때문입니다. 595 가 문자열에 있는지를 판단하는 코드를 작성하기 위해서 문자열 다루는 실습을 해 보겠습니다. 문자열은 추후 유전자서열에 대한 조작을 할 때 많이 쓰이는 함수의 모음으로 다음과 같습니다. substr은 일부 문자열 뽑기, nchar는 문자의 갯수, strsplit는 split 문자를 기준으로 문자열 나누기, sub은 문자열 바꾸기 등 입니다. 각각 실행해 보시고 자세한 설명은 help 페이지를 참고 바랍니다. s &lt;- &quot;This is the sixth lecture of R programming&quot; substr(s, 0, 11) nchar(s) toupper(s) tolower(s) strsplit(s, split=&quot; &quot;) paste(s, &quot; at UST&quot;, sep=&quot;&quot;) sub(&quot;This&quot;, &quot;That&quot;, s) 문자열 다루기에서 흔히 쓰이는 방법 중 하나는 정규식 입니다. 정규식은 특정 문자열의 집합을 표현하는데 사용되는 언어라고 할 수 있으며 대부분의 프로그래밍 언어나 편집기에서 지원하고 있습니다. 아래의 경우 . 은 모든 문자를 나타내고 + 는 바로 앞 문자가 하나 또는 그 이상을 나타내는 기호이므로 .+는 모든 연속되는 문자열을 나타낸다고 할 수 있습니다. 따라서 sub(&quot;This is.+of &quot;, &quot;&quot;, s) 는 This is 부터 of 까지의 문자열을 모두 가리키는 것이고 이를 &quot;&quot; 지우는 명령 입니다. grep 은 s 에 “This” 문자열이 있는지를 검사해서 있으며 1 없으면 0을 반환하고 regexpr의 경우는 있을 경우 시작위치와 끝위치를 리턴하는 함수 입니다. ## regular expression sub(&quot;This is.+of &quot;, &quot;&quot;, s) grep(&quot;This&quot;, s) regexpr(&quot;This&quot;, s) 이제 함수를 업데이트 해 보겠습니다. 마지막 부분의 final_data를 만드는 부분에서 컬럼 이름들을 뽑고 grep을 사용하여 특정 문자열을 (595나 GFP 같은..) 찾은 뒤 해당 문자열이 있는 값을 원하는 값으로 (OD나 ```GFP````)로 바꿔줍니다. 이 후 컬럼 이름을 다시 바뀐 이름으로 저장하면 되겠습니다. ## .... code ## column names cnames &lt;- colnames(final_data) idx &lt;- grep(&quot;595&quot;, cnames) if(length(idx)&gt;0){ cnames[idx] &lt;- &quot;OD&quot; } idx &lt;- grep(&quot;GFP&quot;, cnames) if(length(idx)&gt;0){ cnames[idx] &lt;- &quot;GFP&quot; } idx &lt;- grep(&quot;RFP&quot;, cnames) if(length(idx)&gt;0){ cnames[idx] &lt;- &quot;RFP&quot; } colnames(final_data) &lt;- cnames 두 번째 조건을 하나 더 추가하기 위한 코드를 만들어 봅니다. 함수에서 실험 조건을 parsing 하는 코드는 아래와 같습니다. tmp_final_data$well_conditions 에 1;1;100 형식의 조건을 1;1;phenol;100 형식으로 바꿀경우 sapply 에서 사용한 function에서 names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;concentration&quot;) 부분을 names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;treatment&quot;, &quot;concentration&quot;) 으로만 바꾸어 주면 되겠습니다. ## to make the condition column more readable tmp_final_data &lt;- merge(well_info, mydata_subset, by.x=&quot;well_names&quot;, by.y=&quot;Well&quot;) tmpcond &lt;- sapply(tmp_final_data$well_conditions, function(x){ tmp &lt;- unlist(strsplit(x, &quot;;&quot;)) names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;concentration&quot;) return(tmp) } ) 본 강의에서는 아래처럼 컨디션 문자열을 parsing 하는 함수를 따로 떼어서 만들어서 사용하겠습니다. split_condition &lt;- function(x){ tmp &lt;- unlist(strsplit(x, &quot;;&quot;)) names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;drugname&quot;, &quot;concentration&quot;) return(tmp) } multiple_plate_excel_reader2 &lt;- function(design_file_name, data_file_name){ ### ### ... ### tmpcond &lt;- sapply(tmp_final_data$well_conditions, split_condition) ### ### ... ### } 마지막으로 design excel 파일의 sheet 를 지정하는 코드는 다음과 같이 sheet4design 이라는 파라메터를 추가하고 그 아래 read_excel 함수에서 이 값을 사용하여 sheet를 지정하는 것으로 바꿀 수 있습니다. 업데이트된 파일은 여기 에서 보실 수 있습니다. multiple_plate_excel_reader2 &lt;- function(design_file_name, data_file_name, sheet4design){ require(readxl) ## read excel files mydesign &lt;- as.data.frame(read_excel(design_file_name, sheet=sheet4design, range=&quot;A1:L8&quot;, skip = 0, col_names=F)) mydata &lt;- as.data.frame(read_excel(data_file_name, sheet=1)) ## ... ## ... 7.3 Read data 이제 만들어진 함수를 이용하여 몇 개 파일의 데이터를 읽어보도록 하겠습니다. 총 4개의 실험 파일이 있으며 각 실험 데이터에 대한 조건 정보는 exp_design2.xlsx 파일의 네 개의 sheet에 명시되어 있습니다. 간단히 6개의 세포와 1종류의 약품처리 그리고 11개의 농도 조건과 각 샘플별 반복이 4개 입니다. 아래 4개 파일은 모두 동일한 반복 데이터라고 볼 수 있겠습니다. 이제 우리가 만든 함수의 파라메터에 맞게 값을 입력하고 읽어들이면 mydata1 ~ mydata4 까지 우리가 원하는 포맷의 데이터가 들어가게 되고 rbind 함수로 각각의 데이터를 하나의 오브젝트 (data.frame)로 저장할 있습니다. 함수를 만들지 않았을 경우 각 엑셀 파일마다 우리가 원하는 포맷으로 만들어 주기위한 복잡하고 반복적인 코드를 실행해야 하는 것과 비교하면 훨씬 간단한 작업인 것이고 이러한 재사용성이 함수를 만드는 이유 중 하나가 됩니다. source(&quot;read_plate.R&quot;) design_file_name &lt;- &quot;exp_design2.xlsx&quot; data_file_names &lt;- c(&quot;20171012-phenol-1.xls&quot;, &quot;20171012-phenol-2.xls&quot;, &quot;20171227-phenol-1.xls&quot;, &quot;20171227-phenol-2.xls&quot;) mydata1 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[1], sheet4design=1) mydata2 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[2], sheet4design=2) mydata3 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[3], sheet4design=3) mydata4 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[4], sheet4design=4) mydata &lt;- rbind(mydata1, mydata2, mydata3, mydata4) dim(mydata1) ## [1] 68 7 dim(mydata) ## [1] 304 7 head(mydata) ## well_names OD GFP sample_names replication drugname ## 1 B11 0.8952574 7947 1 1 phenol ## 2 C11 0.8702875 8227 1 1 phenol ## 3 D11 0.8749599 15117 1 1 phenol ## 4 E11 0.9247382 69073 1 1 phenol ## 5 F11 0.8569116 83805 1 1 phenol ## 6 G11 0.8538494 71393 1 1 phenol ## concentration ## 1 0e+00 ## 2 5e-02 ## 3 5e-01 ## 4 5e+00 ## 5 5e+01 ## 6 5e+02 7.4 ggplot 이용 barplot 그리기 데이터 분석에서 데이터를 눈으로 확인하는 것은 중요합니다. 가능하면 raw 데이터를 보면서 크기 비교나 분포를 대략적으로 예측한다면 tool을 사용해서 나오는 결과를 가늠하는 척도가 될 수도 있습니다. 그러나 우리 데이터는 6개의 세포와 11개의 농도 4번의 반복으로 약 308 개의 샘플을 갖는 비교적 큰 데이터 입니다. 이럴 경우 눈으로 확인하는 것은 한계가 있으므로 대부분 그래프나 도표를 그려서 데이터의 분포를 확인하게 됩니다. 농도 포인트가 11개 이므로 각 농도 포인트별로 6개 샘플들의 값의 분포가 어떻게 되어있는지를 나타내는 그림을 그리면 좋을 듯 하므로 ggplot을 이용하여 barplot을 그려보도록 하겠습니다. ggplot은 수업시간에 말씀 드린바와 같이 문법이 있습니다. 간단히 다음과 같은 순서 입니다. 각 요소들은 레이어로 볼 수 있고 각 레이어는 + 기호로 줄을 바꿔가며 명시해 주면 되겠습니다. 데이터 지정 (ggplot) 색상, 크기, x축의 값, y축의 값 등 심미적 요소 지정 (aes) 점, 선, 면 등 기하학적 요소 지정 (geoms) 그릴 통계량 지정 (stats) 테마, 스케일 지정 아래 ggplot2를 로딩후 ggplot을 실행할 경우 데이터와 x, y 축만 지정한 상태로 어떤 그래프 (히스토그램인지, 산포도인지 등)를 그릴지 명시되어 있지 않아서 아무것도 그리지 않은 상태의 빈 켄버스만 그려지게 됩니다. library(ggplot2) ggplot(data=mydata, aes(x=sample_names, y=GFP)) + 로 레이어를 추가하면서 geom_bar() 함수로 막대그래프를 그린다고 명시를 하면 되지만 geom_bar의 기본 stat은 count로 mydata의 GFP 즉 y 값은 count 데이터가 아니므로 에러를 보여줍니다. ggplot(data=mydata, aes(x=sample_names, y=GFP)) + geom_bar() 따라서 stat을 “identity”로 명시하고 그릴 경우 정상적으로 barplot이 그려지게 됩니다. ggplot(data=mydata, aes(x=sample_names, y=GFP)) + geom_bar(stat=&quot;identity&quot;) 위 그림은 반복이나 농도 등을 고려하지 않고 모두 한 위치 (예를 들어 1번 샘플의 반복 및 다른 농도 값들 모두 첫 번째 위치)에 그려지게 됩니다. 따라서 아래와 같이 각 농도를 다른 색으로 채우고 fill=concentration, 위치도 다르게 &quot;position=dodge&quot; 그려줄 수 있습니다. ggplot(data=mydata, aes(x=sample_names, y=GFP, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) 그러나 색은 다른 색으로 보이나 위치는 변경되지 않았습니다. 이는 concentration이라는 변수에 저장된 값들이 numeric 으로 연속형이라 나란히 막대그래프를 위치시킬 수 없기 때문입니다. 이 때는 concentration을 factor 형으로 변환한 후 그리면 됩니다. mydata2 &lt;- mydata mydata2$concentration &lt;- as.factor(mydata2$concentration) ggplot(data=mydata2, aes(x=sample_names, y=GFP, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) 이제 샘플별로 농도별로 값을 한 눈에 볼 수 있습니다. 아래처럼 scale_fill_manual(values = heat.colors(11))를 이용해서 bar의 색을 바꾸거나 ggplot(data=mydata2, aes(x=sample_names, y=GFP, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) + scale_fill_manual(values = heat.colors(11)) color=&quot;black&quot; 으로 태두리 색상도 바꿀 수 있습니다. ggplot(data=mydata2, aes(x=sample_names, y=GFP, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, color=&quot;black&quot;) + scale_fill_manual(values = heat.colors(11)) 그런데 위 그림에 보시면 여전히 한 위치에 다른 그래프가 여러개 그려져 있는 것을 확인하실 수 있고 이는 반복 실험 데이터로서 4개의 반복이 같은 위치에 그려지고 있는 것 입니다. 이럴 경우 보통 평균을 구해서 bar를 그리고 4개의 standard deviation이나 standard error를 구한 후 error를 표시히 주면 됩니다. 그런데 현재 mydata의 값들에서 샘플별로 농도별로 묶은 후 각 4개의 값에 대한 평균과 표준편차를 구하는 일은 일반적인 툴의 경우 번거롭고 시간이 걸리는 작업일 수 있습니다. 다음 시간에는 dplyr 패키지를 사용하여 이러한 평균과 분산을 빠르게 구하고 ggplot을 이용해서 barplot의 error bar 를 표현하는 방법을 알아보도록 하겠습니다. 이 외에도 다른 ggplot의 기능을 사용한 여러 그래프를 그리는 실습을 하도록 하겠습니다. "],
["lecture-07-ggplot-data-transformation.html", "8 Lecture 07 - ggplot / data transformation 8.1 Bar graph with basic graph functions 8.2 Bar graph with ggplot 8.3 Line graph with ggplot 8.4 Bar graph of the example dataset 8.5 ddplyr - pipe operator 8.6 dplyr - Important functions", " 8 Lecture 07 - ggplot / data transformation 지난 시간 실습용 파일들 중 일부가 업데이트 되었습니다. 다시 다운로드 받아 주세요 design excel file 2 data excel file 1 data excel file 2 data excel file 3 data excel file 4 R function for plate read 수업 전 다음 패키지 설치가 필요합니다. 인터넷 연결된 상태에서 Rstudio 콘솔창에 다음을 입력하세요 install.packages(&quot;ggplot2&quot;) install.packages(&quot;dplyr&quot;) 강의 노트 (강의 자료 업데이트가 늦었습니다) Lecture note 이번 강의에서는 두 가지 패키지의 사용법을 알아봅니다. 하나는 ggplot2로 지난 시간에 이어서 barplot 을 그리는 연습을 할 예정이며 다른 하나의 패키지는 dplyr 입니다. dplyr은 plyr의 확장 버전으로 데이터프레임 형식의 데이터를 손쉽게 다룰수 있게 해주는 도구 입니다. 최근 그 유용성이 알려지며 R 사용자들이 많이 쓰는 패키지 중 하나 입니다. 뒤에서 좀 더 자세히 다루기로 하고 ggplot에 대해서 먼저 실습을 해 보겠습니다. 8.1 Bar graph with basic graph functions Bar graph를 그리기 위한 데이터는 강의시간에 소개드린 것처럼 크게 4가지 분류로 나눌 수 있습니다. 아래 예제들이 그 예이며 각각에 대한 bar graph를 그릴 수 있습니다. 이 예제들은 ggplot의 stat 옵션을 설명하기 위한 예제들로 특정 변수에 대한 그래프를 그릴 때 변수의 값들을 count를 해야할지 아니면 그 값 그대로를 그릴지에 대한 설명을 이해하는데 도움을 줄 있습니다. 첫 번째는 x 변수가 연속형 (continuous)인 경우로 대부분의 경우 bar 그래프는 histogram 을 표현하는데 사용 됩니다. 즉, 특정 구간 내에 포함되는 x의 값의 갯수 (count)를 bar로 표현하는 것 입니다. x &lt;- rnorm(100) hist(x, br=10) 두 번째는 하나의 변수 x의 값이 이산형 (discrete) 일 경우에는 x가 갖는 각 값이 몇 개인지를 (count) 나타내기 위해서 bar 그래프를 그릴 수 있을 것 입니다. 아래 코드에서는 x 값 범주의 counting을 위해 table 함수를 사용하였습니다. x &lt;- sample(1:3, 100, replace = T) count_x &lt;- table(x) barplot(count_x) 앞서 두 경우가 하나의 x 변수에 대한 값들을 bar graph로 표현한 경우라면 세 번째와 네 번째 경우는 변수가 두 개인 경우라고 볼 수 있습니다. 그 중 세번째 경우로 두 변수 x, y 가 있을 경우 x가 연속형 값을 갖고 y는 각 x 값의 빈도수를 나타내는 상황을 생각할 수 있습니다. 예를 들어 1.212값을 갖는 데이터가 20개이다 라는 상황을 가정할 경우 x=1.212 가 되고 y=20이 됩니다. 이 경우는 앞에서와 같은 카운팅은 필요 없이 x, y 값 그대로를 화면에 그려주면 됩니다. x &lt;- rnorm(10) y &lt;- rnorm(10) plot(x, y, type=&quot;h&quot;) 마지막으로 앞서와 같이 두 개의 변수로 이루어져 있으나 x가 연속형이 아닌 이산형 변수라는 점이 다릅니다. y는 각 x 값들의 빈도수를 나타내며 이 경우도 x의 빈도수가 y값에 저장되어 있으니 y 값 그대로를 화면에 그려주면 됩니다. x &lt;- 1:3 y &lt;- table(sample(x, 100, replace = T)) barplot(y) 8.2 Bar graph with ggplot 이제 앞서와 같은 4가지 데이터들을 ggplot을 이용하여 차례로 bar graph를 그려 보겠습니다. ggplot의 사용은 강의 시간 설명을 참고하시고 간단히 ggplot 함수로 먼저 데이터와 aes로 (미학요소 또는 미적요소) x축 y축 등을 명시하고 + 오퍼레이터를 사용하여 필요한 레이어를 차례로 추가하면서 그래프를 그릴 수 있습니다. x가 연속형일 경우 아래와 같이 histogram을 그려 줍니다. continuous 일 경우 stat은 bin으로 하면 특정 범위 안에 있는 값들의 빈도수를 계산하여 히스토그램을 그려줍니다. dat &lt;- data.frame(x1=rnorm(100)) ggplot(dat, aes(x=x1)) + geom_bar(stat=&quot;bin&quot;, bins=30) x가 이산형인 경우는 stat을 count로 설정하여 해당 값들의 빈도수를 그려줄 수 있으며 x &lt;- sample(1:3, 100, replace = T) dat &lt;- data.frame(x=factor(x)) ggplot(dat, aes(x=x)) + geom_bar(stat=&quot;count&quot;) 세 번째, 네 번째 경우 x, y 두 변수에서 y가 x의 빈도수를 저장하고 있을 경우 x가 연속형, 이산형에 상관 없이 stat을 identity로 설정하여 bar graph를 그릴 수 있습니다. x &lt;- rnorm(10) y &lt;- rnorm(10) dat &lt;- data.frame(x, y) ggplot(dat, aes(x=x, y=y)) + geom_bar(stat=&quot;identity&quot;) x1 &lt;- as.factor(1:3) y1 &lt;- tabulate(sample(x1, 100, replace=T)) dat &lt;- data.frame(x1, y1) ggplot(dat, aes(x=x1, y=y1)) + geom_bar(stat=&quot;identity&quot;) ggplot은 다음과 같이 다양한 레이어를 추가하여 필요한 기능을 사용할 수 있습니다. x1 &lt;- as.factor(1:3) y1 &lt;- tabulate(sample(x1, 100, replace=T)) dat &lt;- data.frame(x1, y1) ggplot(dat, aes(x=x1, y=y1, fill=x1)) + geom_bar(stat=&quot;identity&quot;) + guides(fill=FALSE) + xlab(&quot;Discrete cases&quot;) + ylab(&quot;Value&quot;) + ylim(c(0,50))+ ggtitle(&quot;Bar graph for x:discrete and y:value&quot;) 8.3 Line graph with ggplot 다음으로 ggplot을 이용한 line graph를 그리는 방법을 알아 봅니다. 앞서 bar graph와의 관계를 보면 line graph는 bar graph의 각 bar에 해당하는 값들을 서로 선으로 이어주는 graph라고 볼 수 있겠습니다. Line graph는 geom_line이라는 함수를 사용해서 그릴 수 있으며 stat의 사용법은 앞서 bar graph와 같습니다. Line graph에서 중요한 점은 아래 group 파라미터 입니다. 선이라는 것은 두 점 이상의 값들을 알 경우에만 연결할 수 있고 ggplot에서는 같은 그룹에 (group) 속해있는 두 개 이상의 값들을 선으로 연결한다는 의미 입니다. 그런데 우리가 가진 데이터 dat 에는 group을 나타내는 변수가 없습니다. 따라서 group=1이라고 할 경우 모든 값들이 같은 1 그룹에 있는 것으로 간주되고 모든 값들을 선으로 연결하는 line 그래프가 그려집니다. bar그래프와 다른 점은 group=1과 geom_bar 대신 geom_line을 사용한 점입니다. 그리고 bar graph의 fill 옵션은 bar의 색을 결정하는 부분으로 line 그래프에서는 bar가 없으므로 사용하지 않습니다. ggplot(dat, aes(x=x1, y=y1, group=1)) + geom_line(stat=&quot;identity&quot;) + guides(fill=FALSE) + xlab(&quot;Discrete cases&quot;) + ylab(&quot;Value&quot;) + ylim(c(0,50))+ ggtitle(&quot;Barplot for x:discrete and y:value&quot;) 추가로 아래와 같이 그려지는 선의 두께를 조절하고 점을 추가로 그려볼 수 있습니다. 점을 그리는 명령어는 geom_point로서 line 과 함께 그리는 것 이므로 + 오퍼레이터를 사용하여 geom_line 과 함께 사용하면 됩니다. ggplot(dat, aes(x=x1, y=y1, group=1)) + geom_line(size=2) + geom_point(size=4, pch=21, fill=&quot;white&quot;) + guides(fill=FALSE) + xlab(&quot;Discrete cases&quot;) + ylab(&quot;Value&quot;) + ylim(c(0,50))+ ggtitle(&quot;Barplot for x:discrete and y:value&quot;) 같은 방법으로 bar 또한 같이 그려줄 수 있습니다. 여기서는 fill 옵션이 geom_bar에 하나 geom_point에 하나씩 쓰였는데 이는 각 geometry에 따라서 필요한 옵션이 다르므로 각각의 geom_xxx 를 사용할 때 상황에 맞게 (help 나 예제를 통해서) 사용하시면 되겠습니다. ggplot(dat, aes(x=x1, y=y1, group=1)) + geom_bar(stat=&quot;identity&quot;, fill=x1) + geom_line(size=2) + geom_point(size=4, pch=21, fill=&quot;white&quot;) + guides(fill=FALSE) + xlab(&quot;Discrete cases&quot;) + ylab(&quot;Value&quot;) + ylim(c(0,50))+ ggtitle(&quot;Barplot for x:discrete and y:value&quot;) 8.4 Bar graph of the example dataset 지난 시간까지 작성했던 엑셀 읽는 함수를 사용해서 (비교적 큰) 실제 데이터를 읽어오고 ggplot을 이용하여 bar graph를 그리는 실습을 합니다. 지난 시간 간단히 bargraph를 그려 보았으나 평균, 표준편차를 구할 필요성이 있었으며 비교적 큰 데이터셋에서 그러한 정보를 뽑아내기 위해 ddplyr 이라는 것을 이용할 것이라고 말씀 드리고 마쳤습니다. 이번 시간 ddplyr의 사용법을 아래에서 배울 예정이며 실제 아래 예제를 가지고 평균, 표준편차 bargraph를 그리는 것은 다음 시간에 실습 하도록 하겠습니다. 대신 지난 시간 그렸던 bargraph를 수정된 데이터가 지고 다시 그려보도록 하겠습니다. 아래 일련의 코드를 실행하면 bargraph를 그릴 수 있으며 연속형으로 되어있는 농도 (concentration)을 이산형으로 바꾸는 과정 및 ggplot을 이용한 bargraph 그리는 과정은 지난시간에 이어 수업시간에 말씀드린 내용을 참고하시면 되겠습니다. source(&quot;read_plate.R&quot;) design_file_name &lt;- &quot;exp_design2.xlsx&quot; data_file_names &lt;- c(&quot;20171012-phenol-1.xls&quot;, &quot;20171012-phenol-2.xls&quot;, &quot;20171227-phenol-1.xls&quot;, &quot;20171227-phenol-2.xls&quot;) mydata1 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[1], sheet4design=1) mydata2 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[2], sheet4design=2) mydata3 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[3], sheet4design=3) mydata4 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[4], sheet4design=4) mydata &lt;- rbind(mydata1, mydata2, mydata3, mydata4) mydata2 &lt;- mydata mydata2$concentration &lt;- as.factor(mydata2$concentration) ggplot(data=mydata2, aes(x=sample_names, y=GFP, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, color=&quot;black&quot;) + scale_fill_manual(values = heat.colors(11)) 8.5 ddplyr - pipe operator dplyr은 테이블형 데이터를 다루기 위한 도구를 제공하는 매우 편리한 패키지 입니다. 앞서 ggplot의 + 오퍼레이터와 같이 %&gt;% 파이프 오퍼레이터를 사용하여 여러 함수를 연속적으로 사용할 수 있으며 R의 장점 중 하나인 apply와 같은 행렬 연산 기능을 subset, split, group 와 같은 행렬 편집 기능과 더하여 만들어낸 도구라고 할 수 있습니다. 먼저 파이프 오퍼레이터 %&gt;% 의 작동법은 간단히 %&gt;%의 왼쪽 코드의 결과를 출력으로 받아 오른쪽 코드의 입력 (첫번째 파라미터의 값)으로 받아들이는 작동을 합니다. 다음 예에서 보면 sin(pi) 와 같은 함수의 일반적인 사용법 대신 pi %&gt;% sin 처럼 사용해도 똑같은 결과를 보여줍니다. cos(sin(pi))와 같이 여러 합수를 중첩하여 사용할 경우에도 코드 디자인의 가독성이나 효율 측면에서 크게 향상된 방법을 제공해 줍니다. library(dplyr) pi %&gt;% sin ## [1] 1.224606e-16 sin(pi) ## [1] 1.224606e-16 pi %&gt;% sin %&gt;% cos ## [1] 1 cos(sin(pi)) ## [1] 1 특히 %&gt;%는 이후 설명할 dplyr의 group_by, split, filter, summary 등의 행렬 편집/연산 함수를 빈번히 다양한 조합으로 쓰게되는 상황에서 더 큰 효과를 발휘할 수 있습니다. 그에 앞서 pipe 오퍼레이터의 예제를 좀 더 살펴보겠습니다. pipe operator의 왼쪽 구문의 결과가 오른쪽 구문의 입력으로 처리된다고 설명드렸지만 엄밀히 따지면 오른쪽 구문의 첫 번째 파라미터의 입력 값으로 처리되는 것 입니다. 즉, 함수에서 사용되는 파라미터가 여러개일 경우가 있으므로 기본적으로 %&gt;% 의 왼쪽 구문의 출력 값은 오른쪽 구문 (함수)의 첫 번째 인자의 입력값으로 들어가는 것 입니다. 이는 다음 예들을 통해서 명확히 알 수 있습니다. 먼저 paste함수는 그 파라미터로 ,로 구분되는 여러개의 입력 값을 가질 수 있습니다. 따라서 다음 코드는 x가 paste의 첫 번째 파라미터로 들어가게 되어 &quot;1a&quot;, &quot;2a&quot;, &quot;3a&quot;, &quot;4a&quot;, &quot;5a&quot; 로 a 앞에 x 값들이 붙어서 출력된 것을 알 수 있습니다. x &lt;- 1:5 x %&gt;% paste(&quot;a&quot;, sep=&quot;&quot;) ## [1] &quot;1a&quot; &quot;2a&quot; &quot;3a&quot; &quot;4a&quot; &quot;5a&quot; 특정 데이터셋의 컬럼별 평균을 구하고 각 평균의 합을 구할 경우를 생각해 봅시다. R에서는 colMeans라는 특별한 함수를 제공하여 컬럼별로 평균을 계산해 줍니다. 그 후 sum 함수를 사용하여 최종 원하는 값을 얻을 수 있습니다. 이러한 코드를 %&gt;% 오퍼레이터를 사용한 경우의 코드와 비교해 볼 수 있습니다. x &lt;- data.frame(x=c(1:100), y=c(201:300)) sum(colMeans(x)) ## [1] 301 x &lt;- data.frame(x=c(1:100), y=c(201:300)) x %&gt;% colMeans %&gt;% sum ## [1] 301 그럼 만약 두 번째 파라미터에 입력으로 왼쪽 구문의 출력을 받아들이고 싶을 경우는 어떻게 할까요? 그럴때는 place holer라는 . 을 사용하면 되겠습니다. round 함수는 두 개의 파라미터를 가지고 digits 값을 pipe operator로 넘겨주고 싶을 경우 아래와 같이 표현할 수 있습니다. 6 %&gt;% round(pi, digits=.) ## [1] 3.141593 round(pi, digits=6) ## [1] 3.141593 8.6 dplyr - Important functions 이제 본격적인 dplyr 함수를 사용해 보겠습니다. dplyr을 구성하는 중요한 함수는 다음 6가지가 있습니다. select() - select columns filter() - filter rows arrange() - re-order or arrange rows mutate() - create new columns summarise() - summarise values group_by() - allows for group operations in the “split-apply-combine” concept 이 함수들은 %&gt;%와 함께 쓰이면서 강력한 성능을 발휘합니다. summarise 함수는 특정 값들의 통계 값을 계산해 주는 함수이며 그 외 5개 함수들은 행렬 편집을 위한 함수들로 보시면 되겠습니다. 각각의 설명보다는 직접 간단한 예제를 수행하면서 각각의 기능을 살펴보고 왜 dplyr이 널리 사용되고 그 장점이 무엇인지 파악해 보도록 하겠습니다. 예제에 사용할 데이터는 iris 데이터로 R을 설치하면 기본으로 들어있는 데이터 입니다. 세 종류의 iris 품종에 대한 꽃잎과 꽃받침의 length와 with를 측정해 놓은 데이터 입니다. head와 str 명령어를 이용해서 데이터를 살펴 봅니다. %&gt;%를 배웠으니 써보겠습니다. iris %&gt;% head(10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa iris %&gt;% str ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 데이터를 확인한 후 분석을 시작합니다. 분석은 간단히 각 iris 품종별로 꽃과 꽃받침의 평균을 비교하는 것으로 합니다. dplyr의 전신이라 할 수 있는 plyr 패키지는 다음과 같이 설명이 되어 있습니다. A set of tools for a common set of problems: you need to split up a big data structure into homogeneous pieces, apply a function to each piece and then combine all the results back together. 즉 split-apply-combine 세 가지 동작을 쉽게 할 수 있도록 만들어 놓은 툴 입니다. R이 다른 언어에 비해 데이터 분석에서 주목을 받는 이유로 split, apply 등의 행렬 연산 함수가 발달한 것을 내세우는데 dplyr은 이들보다 더 편리하게 데이터 조작을 할 수 있도록 만들어 놓은 것 입니다. 이제 split, apply, combine을 활용하여 평균을 구하는 코드와 dplyr 패키지를 사용하여 만든 코드를 비교해 보도록 하겠습니다. split은 factor형 변수인 Species를 기준으로 iris 데이터를 나누어 주는 역할을 하며 lapply는 list 형 데이터인 iris_split을 각 리스트의 각각의 원소들에 대해서 function(x) 를 수행하는 역할을 합니다. 마지막 data.frame으로 최종 경로를 merge 합니다. iris_split &lt;- split(iris, iris$Species) iris_means &lt;- lapply(iris_split, function(x){colMeans(x[,1:4])}) iris_means_df &lt;- data.frame(iris_means) iris_means_df ## setosa versicolor virginica ## Sepal.Length 5.006 5.936 6.588 ## Sepal.Width 3.428 2.770 2.974 ## Petal.Length 1.462 4.260 5.552 ## Petal.Width 0.246 1.326 2.026 위 코드를 한 줄로 사용하여 최종 iris_means_df 데이터를 를 구한다면 다음과 같이 됩니다. 한눈에 코드가 들어오지 않고 이렇게 중첩해서 함수를 사용하는 습관은 어떤 프로그래밍 언어에서도 권장하지 않습니다. iris_means_df &lt;- data.frame(lapply(split(iris, iris$Species), function(x){colMeans(x[,1:4])})) 아래는 dplyr 패키지를 사용한 코드 입니다. iris_means_df2 &lt;- iris %&gt;% group_by(Species) %&gt;% summarise_all(mean) iris_means_df2 ## # A tibble: 3 x 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 1.46 0.246 ## 2 versicolor 5.94 2.77 4.26 1.33 ## 3 virginica 6.59 2.97 5.55 2.03 위에서 보듯 dplyr 패키지를 사용할 경우 그 결과는 같으나 코드의 가독성과 효율성면에서 장점을 보여줍니다. 여기서 group_by, summarise_all 함수 등의 사용법은 help 페이지를 참고해 주세요. 간단히 iris 데이터를 받아서 Species에 명시된 그룹으로 나누고 mean 함수를 모든 컬럼에 대해서 사용하라는 의미 입니다. 이제 ggplot을 이용하여 각 평균에 대한 barplot을 그려보도록 하겠습니다. 지난 예제와는 달리 ggplot에서는 data만 명시해 주고 geom_bar에 aes와 stat을 모두 사용한 것이 다릅니다. ggplot 구문에서 지정해주는 aes 등의 옵션은 하위 geom_xxx 레이어들에 모두 적용이 되고 각 geom_xxx 레이어에서 지정해주는 aes는 해당 레이어에서만 효과를 나타냅니다. ggplot(iris_means_df2) + geom_bar(aes(x=Species, y=Sepal.Length), stat=&quot;identity&quot;) 마지막으로 위 dplyr 패키지를 ggplot 과 함께 사용할 수도 있습니다. 보통은 앞서와 같이 결과를 특정 변수에 저장한 후 도표 등을 그리지만 다음과 같이 %&gt;% 를 사용하여 plot 까지 함께 볼 수도 있습니다. iris %&gt;% group_by(Species) %&gt;% summarise_all(mean) %&gt;% ggplot() + geom_bar(aes(x=Species, y=Sepal.Length), stat=&quot;identity&quot;) 다음시간에는 dplyr 패키지를 이용하여 실제 예제 데이터의 평균과 표준편차를 구해보고 bar graph외 산포도, heatmap 등의 실습을 해 보도록 하겠습니다. "],
["lecture-08-ggplot-data-transformation-using-dplyr.html", "9 Lecture 08 - ggplot / data transformation using dplyr 9.1 dplyr mutate / select 함수 9.2 ggplot2를 이용한 두 개의 bar graph 겹쳐 그리기 9.3 dplyr 이용한 iris data 가공 9.4 ggplot을 이용한 iris data 평균 값 및 에러 비교 그래프 그리기", " 9 Lecture 08 - ggplot / data transformation using dplyr 4월 24일 수요일 강의는 강사 사정으로 휴강하였으며 5월 1일은 근로자의날로 5월 3일 보강을 진행하였습니다. 강의 노트 Lecture note 이번 시간에는 ggplot을 이용한 error bar를 구현하기 위하여 dplyr의 mutate, select, join 함수들 그리고 reshape2 패키지의 melt 함수에대하여 알아보기로 하겠습니다. 수업 전 다음 패키지 설치가 필요합니다. 이미 설치되어 있다면 생략할 수 있습니다. 인터넷 연결된 상태에서 Rstudio 콘솔창에 다음을 입력하세요. install.packages(&quot;ggplot2&quot;) install.packages(&quot;dplyr&quot;) install.packages(&quot;reshape2&quot;) library(ggplot2) library(dplyr) library(reshape2) 9.1 dplyr mutate / select 함수 dplyr패키지의 mutate 함수는 데이터프레임의 특정 변수 값들을 변환 후 새로운 변수를 만들어 추가해 주는 기능을 합니다. 다음 df 데이터는 x, y 두 변수로 이루어져 있으며 각 변수를 표준화한 변수 std_x와 std_y를 생성하고 이 변수들로 새로운 데이터프레임 std_df를 만들어 봅니다. df &lt;- data.frame(x=rnorm(100)+1, y=rnorm(100)+3) std_x &lt;- (df$x-mean(df$x))/sd(df$x) std_y &lt;- (df$y-mean(df$y))/sd(df$y) std_df &lt;- data.frame(std_x, std_y) head(std_df) ## std_x std_y ## 1 -0.02364218 -0.2612072 ## 2 0.33109100 -1.9037197 ## 3 0.39429754 1.5911174 ## 4 0.92322412 -1.1544402 ## 5 0.15621281 0.0308812 ## 6 0.52487460 -0.6504561 위와같은 코드를 사용해도 되겠지만 ‘’’df$’’’ 의 반복적인 사용이 불편합니다. data.frame 만들어주는 라인도 std_x와 std_y 같은 새로운 변수 오브젝트를 생성한 후 std_df를 만들어내므로 메모리적으로도 낭비가 있습니다. 이제 위 코드를 mutate 함수를 사용해서 만들어 봅니다. tmpdf &lt;- mutate(df, std_x=(x-mean(x))/sd(x), std_y=(y-mean(y))/sd(y)) head(tmpdf) ## x y std_x std_y ## 1 0.9494118 2.683960 -0.02364218 -0.2612072 ## 2 1.2905845 1.071830 0.33109100 -1.9037197 ## 3 1.3513749 4.502021 0.39429754 1.5911174 ## 4 1.8600820 1.807250 0.92322412 -1.1544402 ## 5 1.1223915 2.970645 0.15621281 0.0308812 ## 6 1.4769603 2.301911 0.52487460 -0.6504561 위와 같이 사용하면 std_x나 std_y 변수를 따로 만들지도 않고 data.frame으로 따로 묶지 않아도 새로운 변수를 추가해 줍니다. 그러나 우리가 목적한 std_df는 std_x와 std_y만을 필요로 하므로 아래와 같이 select 함수를 연동하면 됩니다. tmpdf &lt;- mutate(df, std_x=(x-mean(x))/sd(x), std_y=(y-mean(y))/sd(y)) std_df &lt;- select(tmpdf, std_x, std_y) head(std_df) ## std_x std_y ## 1 -0.02364218 -0.2612072 ## 2 0.33109100 -1.9037197 ## 3 0.39429754 1.5911174 ## 4 0.92322412 -1.1544402 ## 5 0.15621281 0.0308812 ## 6 0.52487460 -0.6504561 위와 같은 코드가 일반적인 함수를 사용하는 방법입니다. 그런데 tmpdf라는 임의의 변수를 중간에 생성 후 std_df를 만드는 과정이 메모리 관리 측면에서는 비효율적입니다. 이 때 파이프오퍼레이터 %&gt;%를 이용하면 tmpdf 없이 바로 std_df를 만들어 쓸 수 있습니다. std_df &lt;- df %&gt;% mutate(std_x=(x-mean(x))/sd(x), std_y=(y-mean(y))/sd(y)) %&gt;% select(std_x, std_y) head(std_df) ## std_x std_y ## 1 -0.02364218 -0.2612072 ## 2 0.33109100 -1.9037197 ## 3 0.39429754 1.5911174 ## 4 0.92322412 -1.1544402 ## 5 0.15621281 0.0308812 ## 6 0.52487460 -0.6504561 참고로 R은 한 line 별로 명령을 실행하는 스크립트 언어 입니다. 그러나 %&gt;%를 사용한 후 enter를 눌러 라인을 바꾸어도 두 라인으로 인식하지 않고 여전히 한 라인이 계속 이어지는 것으로 인식하여 라인을 실행하지 않습니다. 이는 괄호(를 열어준 후 )로 닫기 전까지는 계속 한 라인으로 인식하는 것과 같습니다. R에서는 한 라인의 명령이 길어질 경우 위와 같은 조건에서 라인을 바꾸어 가독성을 높여주는 코드를 작성합니다. 실행하는 중으로 mutate와 select의 자세한 내용은 help 페이지를 참고하세요. 9.2 ggplot2를 이용한 두 개의 bar graph 겹쳐 그리기 df 데이터프레임에는 x와 y 두 변수가 있습니다. x 하나의 변수에 대해 barplot을 그려보면 다음과 같습니다. hist(df$x, br=50, xlim=c(-4,8)) 여기에 두 번째 변수 의 histogram 을 겹쳐서 그리기 위해서는 다음과 같이 add=T 파라메터를 활용하면 되겠습니다. col 파라메터로 color를 설정해줄 수 있습니다. hist(df$x, br=50, col=&quot;red&quot;, xlim=c(-4,8)) hist(df$y, br=50, col=&quot;blue&quot;, xlim=c(-4,8), add=T) 이제 ggplot을 이용하여 그래프를 그려보겠습니다. 먼저 df의 x에 대한 bar graph를 그리면 다음과 같습니다. df의 x를 x축에 mapping 하고 (aes) stat은 연속형 값을 가지므로 bin으로 합니다. ggplot(df, aes(x=x)) + geom_bar(stat=&quot;bin&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 여기에 y의 historam을 추가하려면 어떻게 할까요? ggplot에서 aes는 데이터와 x, y축 mapping을 설정해 주는 역할을 합니다. 그런데 aes를 geom_xxx 에도 사용할 수 있습니다. ggplot에서 사용된 aes는 그래프 전체에 대한 mapping을 수행하고 geom_xxx에서 aes를 사용할 경우 해당 geometry에 대해서만 mapping 을 수행하게 됩니다. 어렵게 들리실 수 있지만 아래 예제로 이해해 보도록 하겠습니다. ggplot(df) + geom_bar(stat=&quot;bin&quot;, aes(x=x))+ geom_bar(stat=&quot;bin&quot;, aes(x=y)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 즉, x와 y 각각에 대해서 geom_bar를 그리게 된 결과입니다. 다만 이 때는 y축에 그려지는 df$x, df$y가 같은 stat을 사용해야합니다. 또한 x축에 그려질 데이터는 df$x, df$y는 같은 그룹이어야 합니다 (이 경우에 대한 예제는 없습니다). 위 예제의 bar에 칠해지는 색을 다르게 표현해 보도록 하겠습니다. 이번에는 투명한 색으로 칠하여 겹치는 부분의 bar까지 확인할 수 있도록 합니다. ggplot(df)+ geom_bar(aes(x=x), stat=&quot;bin&quot;, fill=&quot;#0000ff55&quot;) + geom_bar(aes(x=y), stat=&quot;bin&quot;, fill=&quot;#ff000055&quot;) + scale_x_continuous(limits=c(-4,8)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 2 rows containing missing values (geom_bar). ## Warning: Removed 2 rows containing missing values (geom_bar). 그러나 보통의 경우 ggplot을 이용하여 두 개 이상의 변수를 한 화면에 그릴때 위와같은 방법을 사용하는 것은 아닙니다. 자세한 내용은 수업시간에 설명드렸으며 간단히 x, y 변수로 구성된 df를 variable과 value로 구성된 데이터프레임으로 변형하여 사용합니다. 즉 다음과 같은 두 변수를 갖는 데이터프레임이 있다고 가정해 봅니다. x &lt;- c(1,3,5,7,9) y &lt;- c(2,4,6,8,10) df &lt;- data.frame(x, y) df ## x y ## 1 1 2 ## 2 3 4 ## 3 5 6 ## 4 7 8 ## 5 9 10 이 데이터프레임을 다음과 같은 variables 와 values로 구성된 데이터프레임으로 변형할 수 있습니다. variables &lt;- c(&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;) values &lt;- c(1,3,5,7,9,2,4,6,8,10) df_melt &lt;- data.frame(variables, values) df_melt ## variables values ## 1 x 1 ## 2 x 3 ## 3 x 5 ## 4 x 7 ## 5 x 9 ## 6 y 2 ## 7 y 4 ## 8 y 6 ## 9 y 8 ## 10 y 10 이러한 표현 형식은 z &lt;- c(11,12,13,14,15) 변수가 추가되어도 여전히 variables와 values 두 변수만으로 표현할 수 있습니다. variables &lt;- c(&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;, &quot;z&quot;, &quot;z&quot;, &quot;z&quot;) values &lt;- c(1,3,5,7,9,2,4,6,8,10,11,12,13,14,15) df_melt &lt;- data.frame(variables, values) df_melt ## variables values ## 1 x 1 ## 2 x 3 ## 3 x 5 ## 4 x 7 ## 5 x 9 ## 6 y 2 ## 7 y 4 ## 8 y 6 ## 9 y 8 ## 10 y 10 ## 11 z 11 ## 12 z 12 ## 13 z 13 ## 14 z 14 ## 15 z 15 이러한 형식의 표현법으로 ggplot을 이용하여 2차원 (x축, y축) 도표를 효율적으로 그릴 수 있습니다. 즉, geom_bar 각각에 aes를 사용하지 않고 ggplot의 aes에서 aes(x=values) 로 표현하고 geom_bar에서는 stat만을 명시하는 것 만으로 여러 변수의 값을 한 도표에 그릴수 있습니다. ggplot(df_melt, aes(x=values, fill=variables))+ geom_bar(stat=&quot;bin&quot;) + scale_x_continuous(limits=c(-2,20)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 6 rows containing missing values (geom_bar). 이러한 variables 와 values를 이용한 새로운 타입의 data.frame 표현형은 reshape2 패키지의 melt 함수를 이용해서 쉽게 전환할 수 있습니다. melt함수는 generic 함수로 입력 인자의 object type에 따라 다른 기능을 수행하며 입력 오브젝트가 data.frame 일 경우 id.vars, measure.vars, vriable.name 세 개의 중요한 파라메터가 있습니다. id.vars는 말 그대로 데이터의 ID (이름) 역할을 할 컬럼 (변수)를 지정해 줍니다. 아무것도 쓰지 않으면 nonmeasured 변수를 사용합니다. measure.vars에는 관측값을 갖는 변수를 지정합니다. 아무것도 쓰지 않으면 non id.vars가 아닌 모든 변수를 사용합니다. variable.name, value.name은 관측값으로 만든 새로운 변수의 이름들을 설정합니다. 아무것도 지정하지 않을 경우 자동으로 variable과 value로 됩니다. 아무것도 지정하지 않은 상태로 실행할 때 No id variables; using all as measure variables 와 같이 안내 메세지를 참고하시면 되겠습니다. library(reshape2) ## Warning: package &#39;reshape2&#39; was built under R version 3.5.3 df_melt2 &lt;- melt(df) ## No id variables; using all as measure variables df_melt2 ## variable value ## 1 x 1 ## 2 x 3 ## 3 x 5 ## 4 x 7 ## 5 x 9 ## 6 y 2 ## 7 y 4 ## 8 y 6 ## 9 y 8 ## 10 y 10 9.3 dplyr 이용한 iris data 가공 errorbar를 그리기 위해서는 평균과 표준편차(또는 표준오차)를 계산해야 하며 iris data를 이용한 실습을 해보겠습니다. dplyr을 사용하지 않고 일반적으로 평균을 구하는 방법은 지난시간 수행해 보았습니다. dplyr의 group_by와 summarize 함수를 사용하고 파이프오퍼레이터를 사용하지 않은 경우 다음과 같습니다. iris_grouped &lt;- group_by(iris, Species) iris_grouped_summary &lt;- summarize(iris_grouped, length_mean=mean(Sepal.Length), length_sd=sd(Sepal.Length)) 앞서 파이프오퍼레이터를 사용하는 이유에 대한 간략한 설명을 한 바와 같이 아래와 같은 코드로 iris_grouped 라는 변수를 중간에 생성하지 않고 바로 원하는 각 그룹별 mean 과 sd 를 갖는 iris_grouped_summary 결과를 얻을 수 있습니다. iris_grouped_summary &lt;- iris %&gt;% group_by(Species) %&gt;% summarize(length_mean=mean(Sepal.Length), length_sd=sd(Sepal.Length)) iris_grouped_summary ## # A tibble: 3 x 3 ## Species length_mean length_sd ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 0.352 ## 2 versicolor 5.94 0.516 ## 3 virginica 6.59 0.636 이제 평균을 bar graph로 그려주면 됩니다. 그러나 문제는 위 평균값은 단지 sepal의 length만을 구한 코드이고 sepal의 width 뿐만 아니라 petal의 length와 width에 대한 평균과 표준편차를 모두 구해야 하는 문제가 남아 있습니다. 위 코드대로라면 summarize 함수에서 각각에 대한 mean과 sd를 수행해야 하지만 이는 각 컬럼 변수별로 mean 과 sd를 구하는 것과 같은 문제이므로 이를 위해서 dplyr에서는 summarize_all 이라는 함수를 제공하고 있습니다. tmp_mean &lt;- group_by(iris, Species) %&gt;% summarise_all(mean) tmp_mean ## # A tibble: 3 x 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 1.46 0.246 ## 2 versicolor 5.94 2.77 4.26 1.33 ## 3 virginica 6.59 2.97 5.55 2.03 그런데 ggplot으로 위 결과의 mean 값들을 보여주기 위해서는 앞서 설명한 것처럼 melt 함수를 이용해서 데이터를 변형해 줄 필요가 있습니다. 위 tmp_mean 변수를 별도 생성하지 않고 최종 목표하는 데이터를 바로 얻어내기 위해서 다음과 같이 melt 함수도 파이프오퍼레이터를 활용합니다. iris_mean_melt &lt;- group_by(iris, Species) %&gt;% summarise_all(mean) %&gt;% melt ## Using Species as id variables head(iris_mean_melt) ## Species variable value ## 1 setosa Sepal.Length 5.006 ## 2 versicolor Sepal.Length 5.936 ## 3 virginica Sepal.Length 6.588 ## 4 setosa Sepal.Width 3.428 ## 5 versicolor Sepal.Width 2.770 ## 6 virginica Sepal.Width 2.974 이제 위와 같이 관측값들은 variable, value 두 종류의 변수로 요약되며 value는 실제 값이고 variable은 각 값의 의미 즉, sepal, petal의 length와 width를 명시하는 값을 가지게 됩니다. 그 외 변수인 Species가 id로 되어 있습니다. 9.4 ggplot을 이용한 iris data 평균 값 및 에러 비교 그래프 그리기 위에서 구한 각 그룹별 평균은 ggplot을 이용하여 다음과 같이 그릴 수 있습니다. x 축에는 species를 그리고 y축 값은 value를 나타내도록 그립니다. 또한 각 bar의 색은 variable에 따라서 다르게 그리고 있습니다. ggplot(iris_mean_melt, aes(x=Species, y=value, fill=variable)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) 이제 에러바를 그리기 위해서 표준편차를 구해봅니다. 표준오차를 에러로 표시하는 것이 신뢰도 검증 측면에서 좋지만 일반적으로 표준편차를 사용하기도 합니다. 표준편차는 앞서 평균을 구하는 방법과 동일한 방법으로 간단히 구할 수 있습니다. iris_sd_melt &lt;- group_by(iris, Species) %&gt;% summarise_all(sd) %&gt;% melt ## Using Species as id variables head(iris_sd_melt) ## Species variable value ## 1 setosa Sepal.Length 0.3524897 ## 2 versicolor Sepal.Length 0.5161711 ## 3 virginica Sepal.Length 0.6358796 ## 4 setosa Sepal.Width 0.3790644 ## 5 versicolor Sepal.Width 0.3137983 ## 6 virginica Sepal.Width 0.3224966 이제 문제는 앞서 iris_mean_melt 와 iris_sd_melt를 합해서 하나의 data.frame으로 만들어야 이를 ggplot에서 받아 평균과 표준편차 값을 그래프에 표시할 수 있다는 것 입니다. 이 때 사용하는 함수가 dplyr 패키지의 join 입니다. 두 데이터 테이블을 merge할때 고려해야할 사항 중 하나가 같은 id를 가진 row끼리 붙여줘야 한다는 것 입니다. 즉 예를 들어 철수, 영희 학생의 키와 몸무게를 따로따로 측정한 후 두 데이터를 합할 때 철수의 키와 영희의 몸무게 값이 같은 row에 오지 않고 몸무게와 키 값이 각각 측정한 사람의 id를 갖는 row에 와야 한다는 것 입니다. join 함수는 떨어진 두 data.frame의 각 id를 자동으로 비교하여 같은 id를 갖는 값끼리 옆으로 붙여줍니다. 자세한 내용은 join의 help 페이지를 참고하시면 좋겠습니다. 본 강의에서는 inner_join을 사용합니다. tmp1 &lt;- group_by(iris, Species) %&gt;% summarise_all(mean) %&gt;% melt(value.name=c(&quot;mean&quot;)) ## Using Species as id variables tmp2 &lt;- group_by(iris, Species) %&gt;% summarise_all(sd) %&gt;% melt(value.name = c(&quot;sd&quot;)) ## Using Species as id variables iris_melt &lt;- inner_join(tmp1, tmp2) ## Joining, by = c(&quot;Species&quot;, &quot;variable&quot;) head(iris_melt) ## Species variable mean sd ## 1 setosa Sepal.Length 5.006 0.3524897 ## 2 versicolor Sepal.Length 5.936 0.5161711 ## 3 virginica Sepal.Length 6.588 0.6358796 ## 4 setosa Sepal.Width 3.428 0.3790644 ## 5 versicolor Sepal.Width 2.770 0.3137983 ## 6 virginica Sepal.Width 2.974 0.3224966 참고로 melt 함수에서 value.name을 지정해 주는 이유는 이 지정 없이 melt 함수를 사용하게 되면 한 쪽 데이터의 평균과 다른 한 쪽 데이터의 표준편차가 모두 같은 이름 value로 저장되어 두 데이터를 합할 수 없기 때문입니다. 이제 아래와 같이 ggplot을 이용하여 error bar를 그려줍니다. ggplot2에서는 geom_errorbar라는 함수를 제공하여 원하는 작업을 쉽게 수행할 수 있습니다. ggplot(iris_melt, aes(x=Species, y=mean, fill=variable)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) + geom_errorbar(aes(min=mean-sd, max=mean+sd), position=&quot;dodge&quot;) 각 errorbar의 길이를 적당히 조절하기 위해 width 옵션을 사용하고 그에 따라 변하는 위치도 조절하기 위해서 position_dodge를 사용합니다. ggplot(iris_melt, aes(x=Species, y=mean, fill=variable)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, color=&quot;black&quot;) + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2, position=position_dodge(0.9)) 마지막으로 ggplot은 + 오퍼레이터로 레이어를 추가하면서 그래프를 그릴 수 있고 이를 특정 변수에 저장한 후 사용할 수도 있습니다. 위 그래프를 아래와 같은 방식으로 코딩해도 같은 결과를 얻을 수 있습니다. p1 &lt;- ggplot(iris_melt, aes(x=Species, y=mean, fill=variable)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, color=&quot;black&quot;) p1 &lt;- p1 + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2, position=position_dodge(0.9)) p1 다음 시간에는 그래프의 detial을 조정하는 scale과 theme 옵션을 추가로 알아보고 96well 데이터에 대해서도 errorbar 를 추가해 보도록 하겠습니다. "],
["lecture-09-ggplot-dlyr-for-96well-fluorescence-data.html", "10 Lecture 09 - ggplot / dlyr for 96well fluorescence data 10.1 dplyr functions 10.2 Data transformation using melt function 10.3 scale and theme of ggplot2 10.4 bargraph for 96well dataset", " 10 Lecture 09 - ggplot / dlyr for 96well fluorescence data 강의 노트 Lecture note 이번 시간에는 dplyr과 reshape2, 그리고 ggplot2를 이용하여 지난 수업들을 통해 만들었던 96well fluorescence 데이터에 대한 bar graph와 error bar를 구현해 보기로 하겠습니다. 계속 강조하는 바와 같이 R의 장점은 데이터 분석에 최적화된 언어 입니다. 데이터 분석에는 통계적 알고리즘을 적용하여 원하는 정보를 도출해내는 것이 핵심이지만 그 전에 가지고 있는 데이터를 눈으로 확인하는 작업이 필수이고 이를 위해 데이터를 적절히 변형하는 작업이 수없이 반복됩니다. dplyr과 reshape2 패키지는 이러한 데이터 변형 작업을 수행하기 위해 가장 선호되는 패키지들 중 하나이며 ggplot2 또한 데이터 가시화를 위해 가장 많이 쓰이는, 즉 가장 효율적인 패키지라고 할 수 있습니다. 이번 시간은 이러한 패키지들의 기본 사용법에 대해 설명하는 마지막 시간이 되겠습니다. 아래와 같이 관련 패키지들을 로딩해 주고 시작합니다. library(ggplot2) library(dplyr) library(reshape2) 10.1 dplyr functions 지난 시간 학습한바와 같이 dplyr패키지에는 select, filter, group_by, summarize, arrange, join, mutate 등의 함수로 이루어져 있습니다. iris data를 가지고 몇 가지 함수에대한 실습을 하겠습니다. 먼저 select 함수는 특정 data.frame에서 원하는 variable을 뽑아주는 기능을 합니다. 첫번째 인자로 data.frame을 넣고 두 번째부터는 해당 data.frame에 있는 변수들 중 뽑고싶은 변수들의 이름을 넣습니다. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa iris_select &lt;- select(iris, Sepal.Length, Sepal.Width, Species) head(iris_select) ## Sepal.Length Sepal.Width Species ## 1 5.1 3.5 setosa ## 2 4.9 3.0 setosa ## 3 4.7 3.2 setosa ## 4 4.6 3.1 setosa ## 5 5.0 3.6 setosa ## 6 5.4 3.9 setosa select 함수가 관심있는 변수(column)를 뽑았다면 filter 함수는 관심있는 데이터(row)를 뽑는 함수로 생각하면 되겠습니다. iris 데이터 중 Species 가 sentosa 인 데이터만 뽑고싶은 경우 다음과 같이 작성하면 됩니다. 주의할 점은 R의 기본 stats 패키지에도 filter라는 함수가 있어서 library(dplyr)로 dplyr 패키지를 읽지 않아도 실행은 되지만 문법이 달라서 에러가 발생할 수 있습니다. str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... iris_filter &lt;- filter(iris, Species==&quot;setosa&quot;) str(iris_filter) ## &#39;data.frame&#39;: 50 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 다음 group_by 함수는 데이터를 특정 기준으로 나누어주는 기능을 합니다. 예를 들어 iris 데이터에는 Species각 3종류가 있고 group_by 함수는 이 3가지 species 별로 데이터를 나누어주는 함수입니다. 이 때 기준이 되는 변수는 factor형이어야 합니다. str(iris_select) ## &#39;data.frame&#39;: 150 obs. of 3 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... iris_group &lt;- group_by(iris_select, Species) str(iris_group) ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 150 obs. of 3 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;groups&quot;)=Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 3 obs. of 2 variables: ## ..$ Species: Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 2 3 ## ..$ .rows :List of 3 ## .. ..$ : int 1 2 3 4 5 6 7 8 9 10 ... ## .. ..$ : int 51 52 53 54 55 56 57 58 59 60 ... ## .. ..$ : int 101 102 103 104 105 106 107 108 109 110 ... ## ..- attr(*, &quot;.drop&quot;)= logi TRUE 이제 summarize 함수를 이용해서 앞서 그룹별로 나누어진 데이터들의 summary를 구할 수 있습니다. 통계에서 summary는 데이터를 나타내는 대푯값으로 중앙을 나타내는 평균, 흩어진정도를 나타내는 분산(표준편차), 최대값, 최소값 등을 말합니다. summarize의 help를 참고하시면 되겠습니다. 앞서 Species 별로 그룹을 나누었고 각 그룹별로 sepal.length와 sepal.width에 대한 평균을 구하는 코드입니다. iris_mean &lt;- summarise(iris_group, mean(Sepal.Length), mean(Sepal.Width)) head(iris_mean) ## # A tibble: 3 x 3 ## Species `mean(Sepal.Length)` `mean(Sepal.Width)` ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 ## 2 versicolor 5.94 2.77 ## 3 virginica 6.59 2.97 그런데 만약 sepal.length, sepal.width 외에도 petal.length, petal.with 등 해당 data.frame (tibble)의 모든 변수(컬럼)에 대한 평균을 구할 경우는 summarize_all 함수를 사용합니다. 위에서 mean(sepal.length) 등 모든 변수들에 대해서 같은 mean 함수를 적용하는 수고를 덜어주는 방법입니다. iris_mean &lt;- summarize_all(iris_group, mean) head(iris_mean) ## # A tibble: 3 x 3 ## Species Sepal.Length Sepal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 ## 2 versicolor 5.94 2.77 ## 3 virginica 6.59 2.97 mean 외에도 앞에서 언급한바와 같이 sd, min, max 등의 함수를 적용하는 것이 가능합니다. iris_sd &lt;- summarize_all(iris_group, sd) head(iris_sd) ## # A tibble: 3 x 3 ## Species Sepal.Length Sepal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 0.352 0.379 ## 2 versicolor 0.516 0.314 ## 3 virginica 0.636 0.322 마지막으로 join 함수 입니다. ggplot을 이용하여 그래프를 그릴 때 모든 필요한 정보는 ggplot의 첫번째 인자로 들어가는 data.frame 안에 들어있어야 합니다. 즉, barplot을 그릴 때 mean 값과 error bar를 그릴 표준편차 (sd)값이 모두 하나의 data.frame 안에 있어야 하므로 앞에서 구한 iris_mean과 iris_sd를 합해서 하나의 data.frame으로 만들어야 합니다. 이렇게 두 데이터를 merge 할 때 주의할 점은 mean 값을 갖는 샘플과 같은 샘플에 sd 값을 붙여주어야 한다는 것 입니다. 즉, cbind로 mean 과 sd 컬럼을 막연히 가져다 붙이면 안되고 각 샘플이 같은지 확인 후 붙여야 합니다. 여기서 각 샘플이 같은지는 합 할 두 data.frame가 갖는 공통의 ID를 비교해서 알 수 있습니다. join 함수의 by 파라미터로 공통의 ID를 지정할 수 있습니다. inner_join, left_join, right_join 등 두 데이터셋의 ID가 같지 않을 경우에 대해서 다른 기능을 수행하는 몇 가지 함수들이 있습니다. 자세한 내용은 help페이지를 참고하세요. 본 예에서는 Species를 공통의 변수로 가지고 있으므로 by=&quot;Species&quot;로 명시해줍니다. 만약 여러 변수를 참조해야 할 경우에는 해당 변수들의 이름을 c() 함수를 이용해서 함께 적어주면 되겠습니다. iris_join &lt;- inner_join(iris_mean, iris_sd, by=&quot;Species&quot;) iris_join ## # A tibble: 3 x 5 ## Species Sepal.Length.x Sepal.Width.x Sepal.Length.y Sepal.Width.y ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 0.352 0.379 ## 2 versicolor 5.94 2.77 0.516 0.314 ## 3 virginica 6.59 2.97 0.636 0.322 10.2 Data transformation using melt function 지난 몇 번의 강의에서 언급한바와 같이 위 iris_join의 경우 처럼 다수의 변수를 갖는 데이터를 ggplot를 이용한 그래프로 표현하기 위해서는 변수이름을 나타내는 변수 하나와 각 변수들의 값을 갖는 변수 하나, 해서 두 개의 변수로 가지고 있는 데이터를 변환해 주는 것이 필요합니다. 위 iris_join 데이터는 sepal.length.x와 sepal.width.x 평균 값을 갖는 변수 2개를 가지고 있는데, 이 데이터를 ggplot으로 그림을 그린다면 x축에는 species를 y축에는 평균을 그려야 하지만 y축 평균을 y=Sepal.Length.x 로 할지 y=Sepal.Width.x 를 할지 하나만을 골라야 합니다. geom_xxx 함수를 여러번 이용해서 다수의 변수 값들을 표현하는 방법이 있을 수 있으나 한정적인 그래프의 경우만 가능하고 변수가 많아질 경우 코드가 복잡해집니다. reshape2 패키지의 melt함수는 위에서 말한 데이터의 변환을 자동으로 수행해주는 함수 입니다. data.frame에 대해서 작동하는 경우만을 생각해 보면 (?melt.data.frame) id.vars 와 measure.vars 두 개의 파라메터를 볼 수 있습니다. measure.vars는 관측한 값이 저장된 변수를 모두 적어줄 수 있고 id.vars 관측값 외의 변수의 이름을 명시해 주어서 ID가 되도록 합니다. 각각의 입력 변수 이름은 사용자가 어떤 데이터를 만들지에 따라서 다르게 입력될 수 있습니다. iris_join 예에서는 Species를 제외한 모든 값들이 관측값이므로 다음과 같이 실행하면 되겠습니다. 가장 처음 column의 factor형 변수가 default로 id로 인식되므로 id.vars=&quot;Species&quot;를 적지 않아도 동일하게 작동합니다 (Species가 id로 사용된다는 메세지 출력). melt(iris_join, id.vars=&quot;Species&quot;) ## Species variable value ## 1 setosa Sepal.Length.x 5.0060000 ## 2 versicolor Sepal.Length.x 5.9360000 ## 3 virginica Sepal.Length.x 6.5880000 ## 4 setosa Sepal.Width.x 3.4280000 ## 5 versicolor Sepal.Width.x 2.7700000 ## 6 virginica Sepal.Width.x 2.9740000 ## 7 setosa Sepal.Length.y 0.3524897 ## 8 versicolor Sepal.Length.y 0.5161711 ## 9 virginica Sepal.Length.y 0.6358796 ## 10 setosa Sepal.Width.y 0.3790644 ## 11 versicolor Sepal.Width.y 0.3137983 ## 12 virginica Sepal.Width.y 0.3224966 위 melt 함수의 파라메터 중 value.name 이라는 인자에는 value 라는 이름 대신 사용하고싶은 이름을 넣을 수 있습니다. 위의 경우 mean과 sd 값이 모두 value라는 변수에 함께 저장되어 있습니다. 그런데 우리가 그려줄 값은 mean 값이고 sd 는 error bar를 그리는데에만 사용될 것입니다. 즉, y축에는 평균만 그리므로 value에서 sd 값들은 제외하고 ggplot의 aes에서 y=value라는 코드로 원하는 그래프를 그릴수 있을 것 입니다. 정리해 보면 위 예에서는 melt 를 사용하기 전에 join으로 mean과 sd 값들을 하나의 value로 merge 했으나 실제로는 join 전에 먼저 melt를 사용해서 모든 평균값과 sd값들을 별개의 변수에 각각 저장하고 그 후 join으로 mean과 sd를 mean은 bar를 그리는데 사용하고 sd는 error bar를 그리는데 사용하는 것이 맞는 순서로 보입니다. 아래는 이러한 일련의 작업들을 %&gt;%를 사용한 코드입니다. iris_mean &lt;- iris %&gt;% group_by(Species) %&gt;% summarise_all(mean) %&gt;% melt(value.name=&quot;mean&quot;) ## Using Species as id variables iris_sd &lt;- iris %&gt;% group_by(Species) %&gt;% summarise_all(sd) %&gt;% melt(value.name=&quot;sd&quot;) ## Using Species as id variables iris_join &lt;- inner_join(iris_mean, iris_sd, by=c(&quot;Species&quot;, &quot;variable&quot;)) iris_join ## Species variable mean sd ## 1 setosa Sepal.Length 5.006 0.3524897 ## 2 versicolor Sepal.Length 5.936 0.5161711 ## 3 virginica Sepal.Length 6.588 0.6358796 ## 4 setosa Sepal.Width 3.428 0.3790644 ## 5 versicolor Sepal.Width 2.770 0.3137983 ## 6 virginica Sepal.Width 2.974 0.3224966 ## 7 setosa Petal.Length 1.462 0.1736640 ## 8 versicolor Petal.Length 4.260 0.4699110 ## 9 virginica Petal.Length 5.552 0.5518947 ## 10 setosa Petal.Width 0.246 0.1053856 ## 11 versicolor Petal.Width 1.326 0.1977527 ## 12 virginica Petal.Width 2.026 0.2746501 위 데이터는 모든 종류의 꽃잎과 꽃받침에 대한 평균과 표준편차를 하나의 테이블로 나타낸 최종 결과입니다. ggplot을 이용하여 평균을 그리고 각각에 대한 표준편차도 error bar로 표시할 수 있게 되었습니다. 지금까지의 데이터와 위치 조정을 통해서 그려진 bar graph는 다음과 같습니다. p1 &lt;- ggplot(iris_join, aes(x=Species, y=mean, fill=variable)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.3, position=position_dodge(0.9)) p1 10.3 scale and theme of ggplot2 이제 ggplot의 scale과 theme에 대해서 알아봅니다. scale은 aes에서 mapping 된 x, y, 그리고 grouped 데이터들의 detail을 지정해주는 역할을 합니다. 따라서 x축, y축, 그리고 몇몇 groupping 된 그래프의 위치, 색상, 크기, 모양 등을 지정해 줍니다. 명령어의 (함수) 형태는 scale_&lt;aesthetic&gt;_&lt;type&gt; 형태이며 &lt;aesthetic&gt;과 &lt;type&gt;에 해당하는 (미리 지정된) 단어를 넣어주면 되겠습니다. 예를 들어 연속형 형태의 y축의 라벨링 이름을 바꾸고 싶을 경우 scale_y_continuous(name=&quot;Label name&quot;)과 같은 형태 입니다. 참고로 이 명령어는 각 축의 label을 바꾸는 명령어는 xlab, ylab와 같은 기능을 합니다. 아래 예에서는 앞서 p1에 저장된 그래프에 scale 옵션을 더해서 p2로 저장해 보겠습니다. bar graph에 색상을 바꾸고 ylab과 xlab 그리고 전체 title과 subtitle등을 지정했습니다. 색상 지정에 대해 자세한 내용은 ?scale_fill_hue 등을 참고하세요. p2 &lt;- p1 + scale_fill_hue(h = c(0, 360)) + ylab(&quot;Length/width Mean2&quot;) + xlab(&quot;Iris species2&quot;) + labs(title = &quot;IRIS Comparison&quot;, subtitle=&quot;Three types of iris&quot;, caption=&quot;Data source: xxx&quot;, fill=&quot;Types&quot;) p2 이제 theme을 바꿔보겠습니다. theme은 내용은 그대로 두고 전체적인 그래프의 생김새를 꾸미는 기능으로 보면 되겠습니다. 크게 각 축의 라벨링, 배경 색상이나 모양, 범례의 모양 위치 등이 그 것 입니다. theme의 도움말에 usage를 보시면 파라메터 이름들이 직관적으로 써 있어서 좀 더 이해하기 편하실 수 있습니다. 특히 기존 만들어진 theme들을 사용할 수 있는데 이 예들은 ?theme_bw에서 보실 수 있습니다. 아래는 theme_bw (black and white) 를 적용하고 거기에 더해서 사용자가 원하는 다른 모양들을 추가로 업데이트 한 예제 입니다. 이를 theme overriding이라고 하는데요 기존 있던 설정의 일부를 바꾸는 작업으로 볼 수 있습니다. p2에 추가작업을 하고 변수에 저장하지 않으므로 바로 화면에 출력 됩니다. p2 + theme_bw() + theme( text=element_text(size=14), axis.text.y = element_text(size=10), axis.title.y = element_text(size=20), axis.title.x = element_text(size=20), legend.position = &quot;bottom&quot;, #legend.position = c(0.1,0.9), plot.title=element_text(hjust=0.5), plot.subtitle=element_text(hjust=0.5) ) 10.4 bargraph for 96well dataset 이제 우리가 읽어들인 (비교적) 큰 데이터 (96 well plate 형광)를 가지고 bar graph와 error bar를 그려보도록 하겠습니다. 아래와 같이 먼저 데이터를 읽어 옵니다. 일곱번째 강의 시간에 작성한 코드가 (multiple_plate_excel_reader2 함수) c:\\Rprog\\07\\read_plate.R 위치에 있습니다. 각자 맞는 위치와 파일 이름을 넣어주시면 되겠습니다. setwd(&quot;C:\\\\Rprog\\\\07&quot;) source(&quot;read_plate.R&quot;) design_file_name &lt;- &quot;exp_design2.xlsx&quot; data_file_names &lt;- c(&quot;20171012-phenol-1.xls&quot;, &quot;20171012-phenol-2.xls&quot;, &quot;20171227-phenol-1.xls&quot;, &quot;20171227-phenol-2.xls&quot;) mydata1 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[1], sheet4design=1) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems ## New names: ## * Time -&gt; Time...5 ## * Time -&gt; Time...7 mydata2 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[2], sheet4design=2) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems ## New names: ## * Time -&gt; Time...5 ## * Time -&gt; Time...7 mydata3 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[3], sheet4design=3) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems ## New names: ## * Time -&gt; Time...5 ## * Time -&gt; Time...7 mydata4 &lt;- multiple_plate_excel_reader2(design_file_name, data_file_names[4], sheet4design=4) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems ## New names: ## * Time -&gt; Time...5 ## * Time -&gt; Time...7 mydata &lt;- rbind(mydata1, mydata2, mydata3, mydata4) mydata2 &lt;- mydata mydata2$concentration &lt;- as.factor(mydata2$concentration) str(mydata2) ## &#39;data.frame&#39;: 304 obs. of 7 variables: ## $ well_names : chr &quot;B11&quot; &quot;C11&quot; &quot;D11&quot; &quot;E11&quot; ... ## $ OD : num 0.895 0.87 0.875 0.925 0.857 ... ## $ GFP : num 7947 8227 15117 69073 83805 ... ## $ sample_names : Factor w/ 6 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 1 1 1 1 1 2 2 2 2 ... ## $ replication : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ drugname : Factor w/ 1 level &quot;phenol&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ concentration: Factor w/ 11 levels &quot;0&quot;,&quot;0.05&quot;,&quot;0.1&quot;,..: 1 2 4 6 8 10 1 1 1 1 ... concentration 을 as.factor로 전환해주는 이유는 x축에 그려질 bar들이 histogram이 아니고 각각 하나씩의 값을 갖는 이산형 데이터이므로 factor 형태로 바꾸어 주어야 합니다. 이제 dplyr 패키지를 이용해서 반복 측정값들의 평균 GFP값과 표준편차를 구합니다. 먼저 어떤 변수를 기준으로 groupping을 할지 지정해 줍니다. 이는 replication을 제외한 모든 변수 sample_name, drugname, concentration이 되겠습니다. 그리고 summzarize로 그룹핑된 값들의 평균값을 계산합니다. grouped_data &lt;- group_by(mydata2, sample_names, drugname, concentration) data_mean &lt;- summarize(grouped_data, gfp_mean=mean(GFP)) head(data_mean) ## # A tibble: 6 x 4 ## # Groups: sample_names, drugname [1] ## sample_names drugname concentration gfp_mean ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 1 phenol 0 4148. ## 2 1 phenol 0.05 5648. ## 3 1 phenol 0.1 3208 ## 4 1 phenol 0.5 9790. ## 5 1 phenol 1 3343 ## 6 1 phenol 5 35226. 또한 에러바를 위한 표준편차 값을 구하고 위에서 학습한바와 같이 평규과 표준편차를 같은 row로 붙여주는 join을 수행합니다. 이 때 sample_name, drugname, concentration이 모두 같은 샘플끼리 평균과 표준편차를 붙여야 하므로 다음과 같이 by 뒤 위 변수들을 모두 명시해 줍니다. 참고로 data_mean과 data_sd에는 위 세개의 변수가 모두 같은 이름으로 저장되어 있습니다. data_sd &lt;- summarize(grouped_data, sd=sd(GFP)) data_join &lt;- inner_join(data_mean, data_sd, by=c(&quot;sample_names&quot;, &quot;drugname&quot;, &quot;concentration&quot;)) head(data_join) ## # A tibble: 6 x 5 ## # Groups: sample_names, drugname [1] ## sample_names drugname concentration gfp_mean sd ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 phenol 0 4148. 1981. ## 2 1 phenol 0.05 5648. 2849. ## 3 1 phenol 0.1 3208 84.9 ## 4 1 phenol 0.5 9790. 7520. ## 5 1 phenol 1 3343 112. ## 6 1 phenol 5 35226. 36730. 이제 ggplot으로 그림을 완성하면 되며 scale과 theme을 적절히 활용하여 원하는 그래프를 그리면 되겠습니다. ggplot(data_join, aes(x=sample_names, y=gfp_mean, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, color=&quot;black&quot;) + scale_fill_manual(values = heat.colors(11)) + geom_errorbar(aes(min=gfp_mean-sd, max=gfp_mean+sd), width=.2, position=position_dodge(0.9)) p1 &lt;- ggplot(data_join, aes(x=sample_names, y=gfp_mean, fill=concentration)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, color=&quot;black&quot;) + geom_errorbar(aes(min=gfp_mean-sd, max=gfp_mean+sd), width=.2, position=position_dodge(0.9)) p1 + scale_fill_hue(h = c(0, 360)) + ylab(&quot;GFP&quot;) + xlab(&quot;Concentration&quot;) + labs(title = &quot;GFP profiles for drug xxx&quot;, subtitle=&quot;6 samples and 11 concentrations&quot;, caption=&quot;Data source: xxx&quot;, fill=&quot;Conc.&quot;) + theme_bw() + theme( text=element_text(size=14), axis.text.y = element_text(size=10), axis.title.y = element_text(size=20), axis.title.x = element_text(size=20), plot.title=element_text(hjust=0.5), plot.subtitle=element_text(hjust=0.5) ) "],
["lecture-10-sequence-analysis-in-r-i.html", "11 Lecture 10 - Sequence analysis in R I 11.1 Biostrings package for sequence analysis 11.2 Download sequence information from NCBI", " 11 Lecture 10 - Sequence analysis in R I 강의 노트 Lecture note 이번 시간부터는 R을 이용한 서열분석에 대해서 알아보겠습니다. 지난 시간까지 배운 내용은 함수를 만들고 사용하는 법과 ggplot2 패키지를 이용한 그래프 그리는 방법 그리고 dplyr 패키지를 이용한 데이터 재구성 방법 등에 대해서 배웠습니다. R을 이용한 서열 분석도 기본적으로는 패키지를 사용하는 방법에 관한 내용입니다. 서열을 다루기 위한 기본 툴은 Biostrings 입니다. 그리고 NCBI 데이터를 활용하기 위한 reutils와 다음 시간에 배울 서열 분석 툴인 DECIPER를 배우게 되겠습니다. 수업시간에 설명 드린것 처럼 R로 생물학 데이터를 분석하기 위해서는 Bioconductor라는 사이트를 먼저 이해해야 합니다. R 기반의 생물정보학 툴과 데이터 그리고 분석 방법 등을 공유하고 제공하는 곳으로 대부분의 생물학 관련 패키지도 이 곳에서 얻을 수 있습니다. 강의노트와 수업시간 설명드린 내용을 참고하시면 되겠습니다. 11.1 Biostrings package for sequence analysis 먼저 Biostrings는 아래와 같이 Bioconductor에서 제공하는 코드를 이용해서 설치할 수 있습니다. if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;Biostrings&quot;) library(Biostrings) ## Warning: package &#39;Biostrings&#39; was built under R version 3.5.2 Biostrings 패키지는 기본적으로 XString, XStringSet, XStringViews 3가지의 class를 정의하고 있습니다. XString은 DNA나 RNA, AA 등 생물학적 서열 한 가닥을 다루기위한 클래스이며 XStringSet은 여러 가닥을 다루기위한 클래스 입니다. 여기서 참고로 class의 개념을 좀 더 확실히 이해하고 가는 것이 좋습니다. 우리가 배운 class는 vector, array, data.frame, matrix, list, factor 정도가 있습니다. 이들은 data type이나 object type 등으로 불리우며 사용자가 임의로 새로운 class를 정의할 수 있습니다 (numeric, logical, character 등은 core data type 또는 mode라고 부릅니다). XString 또한 개발자들이 만들어 놓은 object type들 중 하나로 생각하시면 됩니다. 다음 predefined constants 들은 Biostrings 패키지를 로드하면 자동으로 저장되는 변수들로 생물학적 서열을 미리 정의해 놓았습니다. DNA_BASES ## [1] &quot;A&quot; &quot;C&quot; &quot;G&quot; &quot;T&quot; DNA_ALPHABET ## [1] &quot;A&quot; &quot;C&quot; &quot;G&quot; &quot;T&quot; &quot;M&quot; &quot;R&quot; &quot;W&quot; &quot;S&quot; &quot;Y&quot; &quot;K&quot; &quot;V&quot; &quot;H&quot; &quot;D&quot; &quot;B&quot; &quot;N&quot; &quot;-&quot; &quot;+&quot; ## [18] &quot;.&quot; IUPAC_CODE_MAP ## A C G T M R W S Y K ## &quot;A&quot; &quot;C&quot; &quot;G&quot; &quot;T&quot; &quot;AC&quot; &quot;AG&quot; &quot;AT&quot; &quot;CG&quot; &quot;CT&quot; &quot;GT&quot; ## V H D B N ## &quot;ACG&quot; &quot;ACT&quot; &quot;AGT&quot; &quot;CGT&quot; &quot;ACGT&quot; 위 변수들을 이용하면 다음처럼 랜덤하게 DNA 서열을 얻을 수 있습니다. DNA_BASES가 4개 길이를 갖는 벡터인데 이 중 10개를 뽑으려면 replace=T로 해야 합니다. paste함수는 문자열을 붙이는 기능을 하며 서열을 다루는데 필수인 함수로 그 사용법을 정확히 알아두면 좋습니다. help 페이지를 보면 sep과 collapse라는 두 개의 파라메터를 갖는데요 이 두 파라메터의 용도는 sep의 경우 서로 다른 문자열을 붙일 때 (즉 다른 변수에 저장된 여러 문자열) 어떤 문자를 사이에 넣을지를 결정하는 파라메터이고 collapse는 한 변수에 저장된 여러 문자열을 붙일 때 사이에 넣는 문자를 결정하는 파라메터 입니다. x0 &lt;- sample(DNA_BASES, 10, replace = T) x0 ## [1] &quot;C&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;T&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;T&quot; &quot;T&quot; x1 &lt;- paste(x0, collapse=&quot;&quot;) x1 ## [1] &quot;CCAATTGATT&quot; XString 클래스 특히 DNAString 클래스의 사용법은 다음 코드를 통해 익힐 수 있습니다. length 함수는 핵산의 갯수를 (DNAStringSet 타입의 변수에서 length는 DNA 가닥의 갯수이며 핵산의 갯수는 nchar함수로 얻어낼 수 있습니다. toString은 DNAString 타입을 단순 문자열로 변환해주는 함수이며 상보서열, 역상보서열 등의 정보도 complement, reverseComplement 등을 사용하여 찾아낼 수 있습니다. x0 &lt;- paste(sample(DNA_BASES, 10, replace = T), collapse=&quot;&quot;) x1 = DNAString(x0) class(x0) class(x1) length(x1) toString(x1) complement(x1) Biostrings::complement(x1) reverseComplement(x1) DNAString의 인덱싱은 vector (string)과 같으며 DNAStringSet은 list의 인덱싱과 같습니다. ## indexing x1[1] x1[1:3] subseq(x1, start=3, end=5) subseq(x1, 3, 5) ## letter frequency alphabetFrequency(x1, baseOnly=TRUE, as.prob=TRUE) letterFrequency(x1, c(&quot;G&quot;, &quot;C&quot;), as.prob=TRUE) 11.1.1 Exercise 10-1 x0 &lt;- paste(sample(DNA_BASES, 30, replace = T), collapse=&quot;&quot;) x0 x1 &lt;- paste(&quot;ATG&quot;, x0, &quot;TAG&quot;, sep=&quot;&quot;) x1 x1 &lt;- DNAString(x1) x1 class(x1) complement(x1) translate(x1) DNAStringSet class는 여러개의 DNAString 을 모아 놓은 집합이라고 보면 됩니다. length 함수는 DNA string의 갯수이며 width 또는 nchar 함수로 각 string의 길이를 구할 수 있으며 이 외 대부분의 DNAString 에서 사용되는 함수가 동일하게 사용될 수 있습니다. x0 &lt;- c(&quot;CTC-NACCAGTAT&quot;, &quot;TTGA&quot;, &quot;TACCTAGAG&quot;) x1 &lt;- DNAStringSet(x0) class(x0) class(x1) names(x1) names(x1) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) length(x1) width(x1) subseq(x1, 2, 4) x1[[1]] x1[1] alphabetFrequency(x1, baseOnly=TRUE, as.prob=TRUE) letterFrequency(x1, c(&quot;G&quot;, &quot;C&quot;), as.prob=TRUE) 11.1.2 Exercise 10-2 이번 예제는 앞서 10-1과 같은 방법으로 10개의 서열을 만드는 것입니다. 아래는 가장 직관적으로 생각할 수 있는 for를 이용한 방법입니다. 즉, 10개 저장소를 갖는 x0 변수를 미리 생성해 두고 for 문을 돌면서 앞서 10-1예제와 같은 방법으로 서열을 하나씩 만들어 저장하는 방법입니다. x0 &lt;- rep(&quot;&quot;, 10) for(i in 1:length(x0)){ tmp &lt;- paste(sample(DNA_BASES, 30, replace = T), collapse=&quot;&quot;) x0[i] &lt;- paste(&quot;ATG&quot;, tmp, &quot;TAG&quot;, sep=&quot;&quot;) } x0 ## [1] &quot;ATGTAGCCCTACTGGTGGCCAGCCGCTAGTTTATAG&quot; ## [2] &quot;ATGGGATCTAAGTAGCTACGGAACTTGCGGGTGTAG&quot; ## [3] &quot;ATGAAGTGCGTAGTTTAGGCTTTTAATCGAACCTAG&quot; ## [4] &quot;ATGGCGTAGCCTCCTCAGCTGTCCCCGTGAAGTTAG&quot; ## [5] &quot;ATGCGTTGTATCACTAGTATAACAACCTTATGATAG&quot; ## [6] &quot;ATGAGTGTTGCTTTACTGTTCGCCCTACGCATGTAG&quot; ## [7] &quot;ATGGACGGCTATGTCGTCCAGTAACACTATGGGTAG&quot; ## [8] &quot;ATGCCCAATTCTACCGACGCTTCCGTATCTAAATAG&quot; ## [9] &quot;ATGTAGTGGCACAAAGCGTCGTGCAGCACAGGTTAG&quot; ## [10] &quot;ATGAGTATTCTGAAAGCTAGGGATGGATTCGAGTAG&quot; 위 코드를 지금까지 배운 내용들에 있는 편리한 기능을 사용해서 만들어 보겠습니다. 위 코드는 random dna를 만들 때 길이만 다를뿐 같은 코드를 반복해서 사용하고 있습니다. 이럴 경우 DNA 길이를 사용자가 정해주도록 input parameter로 하고 해당 파라메터를 받아 DNA를 만들어 주는 함수를 만들어 사용하면 편리합니다. random_dna &lt;- function(len){ tmp &lt;- paste(sample(DNA_BASES, len, replace = T), collapse=&quot;&quot;) x0[i] &lt;- paste(&quot;ATG&quot;, tmp, &quot;TAG&quot;, sep=&quot;&quot;) return(x0) } 파라메터로 넘겨진 len 값이 sample 함수의 len에 사용된 것을 참고하세요. 또한 다음처럼 파이프오퍼레이터 %&gt;%를 사용해서 함수 내부 코드를 한 줄로 바꿀수도 있습니다. random_dna &lt;- function(len){ DNA_BASES %&gt;% sample(len, replace=T) %&gt;% paste(collapse=&quot;&quot;) %&gt;% paste(&quot;ATG&quot;, ., &quot;TAG&quot;, sep=&quot;&quot;) } 이제 길이 30bp짜리 10개의 서열을 반복해서 만들 때 위 함수를 앞서와 같이 for문을 이용하여 10번 반복해서 실행해 주면 같은 결과를 얻습니다. 위와 같이 함수를 만들어 두면 언제든 DNA 서열을 만들 때 재사용 할 수 있습니다. x0 &lt;- rep(&quot;&quot;, 10) for(i in 1:length(x0)){ x0[i] &lt;- random_dna(30) } x0 ## [1] &quot;ATGGATTGCACGGGACGCCCTATAAATGGGTGTTAG&quot; ## [2] &quot;ATGGCCGTGCGCGTCAGGATAAAATGTATGGAATAG&quot; ## [3] &quot;ATGATGAGCTGTGACGACGCAAACCTCGCTAAATAG&quot; ## [4] &quot;ATGGACCAATGAGGCACGATGTTCGTGCCCGCTTAG&quot; ## [5] &quot;ATGTGGAACAACCGAAAGTTGTAATTGCGTAGTTAG&quot; ## [6] &quot;ATGTTGTCTAAGGCTAGCTCCAATGCTCCCCATTAG&quot; ## [7] &quot;ATGGAAAGCGCTCGTTGCTGGCTCCAAGAGAGCTAG&quot; ## [8] &quot;ATGAGACCAGGTGCCTGGAGGATGTCATCATGATAG&quot; ## [9] &quot;ATGTTTCCTTATTTCGCTAGAAATATGTTGCATTAG&quot; ## [10] &quot;ATGGTATCTAAACACTTTGAGGACGCTTAACACTAG&quot; 그런데 R에는 apply 와 같은 행렬연산 함수가 있어서 for문을 사용하지 않고 편리하게 반복문을 실행할 수 있습니다. replicate 함수는 apply와 같은 기능으로 list나 vector 변수에 대해서 사용할 수 있습니다. 즉, 다음과 같이 사용자가 원하는 함수를 반복해서 실행하고 반복 수 만큼의 길이를 갖는 결과를 반환합니다. x0 &lt;- replicate(10, random_dna(30)) x0 ## [1] &quot;ATGCGCGGGTTGAATAAACGTTGACTTAATATGTAG&quot; ## [2] &quot;ATGATGCGGCGGAAACAAGTTCCATAGTGTCACTAG&quot; ## [3] &quot;ATGGGCCCATATTTGCCATCGATTGTGCATCTGTAG&quot; ## [4] &quot;ATGGCGCTTGATTTCTACCTCAGTCCTGCATCGTAG&quot; ## [5] &quot;ATGATGCGAAACTTCACGGTCCAACACAATGTGTAG&quot; ## [6] &quot;ATGGTCCGCACCCCCCAGTAACCTTCAGTAGGATAG&quot; ## [7] &quot;ATGCGTCAACTAGCTCCTCTCTCACAGGCGCGCTAG&quot; ## [8] &quot;ATGGAAACTCTGTCACGCTCGGACAATGCATTTTAG&quot; ## [9] &quot;ATGTATAGTTGCTACCAGTCACGAATGGAACGGTAG&quot; ## [10] &quot;ATGGACCGCAAACGTTCCCGCACAGGTACTGTATAG&quot; 위 x0 스트링들을 XStringSet으로 바꾸고 GC 비율을 구한 후 ggplot을 이용하여 bargraph를 그리는 코드는 다음과 같습니다. gc_ratio가 G와 C의 비율값을 저장한 10x2 테이블이므로 x축에 10개의 서열과 각 서열의 GC비율을 나타내고 y축에 비율 값을 그리는 것으로 생각한 후 ggplot의 aes와 파라메터를 적절히 지정해 줍니다. x1 &lt;- DNAStringSet(x0) gc_ratio &lt;- letterFrequency(x1, c(&quot;G&quot;, &quot;C&quot;), as.prob=TRUE) gc_ratio_melt &lt;- melt(gc_ratio) print(gc_ratio_melt) ## Var1 Var2 value ## 1 1 G 0.2777778 ## 2 2 G 0.2777778 ## 3 3 G 0.2500000 ## 4 4 G 0.2222222 ## 5 5 G 0.2222222 ## 6 6 G 0.2222222 ## 7 7 G 0.2222222 ## 8 8 G 0.2222222 ## 9 9 G 0.2777778 ## 10 10 G 0.2500000 ## 11 1 C 0.1111111 ## 12 2 C 0.1944444 ## 13 3 C 0.2222222 ## 14 4 C 0.2777778 ## 15 5 C 0.2222222 ## 16 6 C 0.3333333 ## 17 7 C 0.3611111 ## 18 8 C 0.2222222 ## 19 9 C 0.1666667 ## 20 10 C 0.2777778 ggplot(gc_ratio_melt, aes(x=Var1, y=value, fill=Var2)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) Biostrings의 마지막 class인 XStringView는 XString class의 DNA서열을 사용자가 원하는대로 볼 수 있는 인터페이스를 제공합니다. 사용법은 다음과 같습니다. x2 &lt;- x1[[1]] Views(x2, start=1, width=20) Views(x2, start=1, end=4) Views(x2, start=c(1,3), end=4) Views(x2, start=c(1,3,4), width=20) Views(x2, start=c(1,3,4), width=20) 다음과 같이 한 서열에 대한 여러 부분의 서열 조각도 볼 수 있으며 gaps 함수는 매개변수로 주어진 서열 view의 구간을 제외한 나머지 구간의 서열을 보여주는 함수입니다. successiveviews 함수는 처음 서열부터 매개변수 width에 주어진 갯수 만큼의 서열을 보여주며 rep() 함수를 이용해서 서열의 처음부터 끝까지 보여주는 기능을 합니다. v &lt;- Views(x2, start=c(1,10), end=c(3,15)) gaps(v) successiveViews(x2, width=20) successiveViews(x2, width=rep(20, 2)) successiveViews(x2, width=rep(20, 3)) 11.1.3 Excercise 10-3 1000bp 길이의 랜덤 DNA 서열을 만들고 40bp 단위의 길이로 보는 코드 입니다. 앞서 만들어둔 random_dna() 함수를 사용하면 되겠습니다. successiveview 함수를 사용해야 하므로 DNAString으로 변환이 필요하며 서열의 길이에 따라서 rep() 를 이용한 반복 횟수를 자동으로 계산하기 위해서 다음처럼 코딩할 수 있습니다. x0 &lt;- random_dna(1000) x1 &lt;- DNAString(x0) successiveViews(x1, width=rep(40, (nchar(x1)/40)+1)) ## Views on a 1006-letter DNAString subject ## subject: ATGGATCCGGCAGGGCGGTGAATAGTGCTTTA...AACTGCGGCTCAGCCGGAAATGGGCAGGTAG ## views: ## start end width ## [1] 1 40 40 [ATGGATCCGGCAGGGCGGTGAATAGTGCTTTAGCTAGTTA] ## [2] 41 80 40 [GTATTGCGTGAAGTCTTTAATGTGGCTGCTACCGTACGGG] ## [3] 81 120 40 [ACGACGACTTCAGTTTTGTTACCCTAGGGCAGCCTATTTC] ## [4] 121 160 40 [CCATTTTATATGCAATCCAACGAGCGGCGCACTACATGAA] ## [5] 161 200 40 [TTCTGAGTTAGAGTAAGTATATCGAATGAAATACCGGCGG] ## ... ... ... ... ... ## [22] 841 880 40 [AGAATTAATATTGACTGCTAGCACAGCGGTAGGAGGAATT] ## [23] 881 920 40 [TGGACCCAAACGGCCATCCCCGGCAAACAGGATTTAACCG] ## [24] 921 960 40 [AAGAGTGCATGCATAGTCGTTATGTTAAAGCTGGATAGCT] ## [25] 961 1000 40 [GGCGCACTAGCGAAAAACTGCGGCTCAGCCGGAAATGGGC] ## [26] 1001 1040 40 [AGGTAG ] 11.2 Download sequence information from NCBI 전세계 연구자들이 서열 데이터를 분석하는데 가장 많이 이용하는 사이트 중 하나가 NCBI 이며 따라서 NCBI에서는 연구자들이 데이터베이스에 접근하기위한 편리한 방법을 제공하고 있고 그 중 하나가 Entrez 입니다. R에서도 Entrez 기능을 도입한 package들이 제공되고 있으며 그 중 하나가 reutils 입니다. https://www.ncbi.nlm.nih.gov/books/NBK25500/ 이 곳의 Downloading Full Records 를 참고하시면 좋습니다. Entrez는 대략적으로 다음 9개의 유틸리티를 제공합니다. EInfo (database statistics) ESearch (text searches) EPost (UID uploads) ESummary (document summary downloads) EFetch (data record downloads) ELink (Entrez links) EGQuery (global query) ESpell (spelling suggestions) ECitMatch (batch citation searching in PubMed) 이 중 ESerach, EPost, ESummary, EFetch 등이 많이 사용하는 유틸이며 정보를 다운로드 받을 경우는 EFetch 를 주로 사용하게 됩니다. 예제로 뎅기바이러스 서열 4종을 다운로드 하겠습니다. NCBI의 accession 번호를 알 경우이며 각각에 대한 accession no.는 NC_001477, NC_001474, NC_001475 and NC_002640 입니다. acc &lt;- c(&quot;NC_001477&quot;, &quot;NC_001474&quot;, &quot;NC_001475&quot;, &quot;NC_002640&quot;) ep &lt;- epost(acc, &quot;nuccore&quot;) ef &lt;- efetch(ep, retmode = &quot;text&quot;, rettype = &quot;fasta&quot;) nc &lt;- content(ef) "],
["lecture-11-sequence-analysis-in-r-ii.html", "12 Lecture 11 - Sequence analysis in R II 12.1 Genbank data parsing 12.2 IRanges for genome view 12.3 Feature view using IRanges and ggplot2", " 12 Lecture 11 - Sequence analysis in R II 강의 노트 Lecture note R을 이용한 서열분석 두 번째 시간입니다. 지난시간 NCBI 데이터를 활용하기 위한 reutils에 대한 내용에 이어서 서열 데이터를 다루기 위한 방법들을 배우도록 하겠습니다. 또한 예제에서 나오는 프로그래밍에 익숙해지기 위한 for, if, 그리고 함수를 만드는 법에 대한 내용도 참고하시기 바랍니다. 설치 필요 패키지 (사전 설치 필요). 설치는 다음 패키지들을 CRAN (RStudio 패키지 설치) 또는 Bioconductor 사이트에서 검색 후 지시에 따라 설치하시면 되겠습니다. genbankr GenomicRanges ggbio msa seqinr ape 뎅기바이러스 데이터 다운로드 NC_001477 NC_001474 NC_001475 NC_002640 지난시간에는 reutils 패키지를 이용해 fasta format의 뎅기바이러스 데이터를 다운로드 받았습니다. 이번에는 gb (genbank) format의 데이터를 받아보도록 하겠습니다. genbank 포맷의 데이터는 서열 정보 뿐만 아니라 서열에 위치한 CDS 등 유전자 및 전사된 단백질 정보를 포함하고 있습니다. 다음 코드로 뎅기바이러스 4종에 대한 genbank 포맷의 데이터를 다운로드 할 수 있습니다. 앞서와 같이 4종에 대한 accession 번호를 알고 있다고 가정합니다. 중요한 부분은 efetch 입니다. 앞서 9개의 주요 함수들 중 특정 정보를 찾을때는 esearch를 사용하고 데이터를 다운로드 받을 때는 efetch를 사용한다고 말씀 드렸습니다. 지난시간 보았던 fasta format 다운로드 예제와 같이 efetch의 첫 번째와 두 번째 파라메터는 epost 함수를 사용하여 그 리턴값으로 대신할 수도 있습니다. library(reutils) acc &lt;- c(&quot;NC_001477&quot;, &quot;NC_001474&quot;, &quot;NC_001475&quot;, &quot;NC_002640&quot;) for(i in 1:length(acc)){ ef &lt;- efetch(acc[i], &quot;nuccore&quot;, retmode = &quot;text&quot;, rettype = &quot;gb&quot;) write(content(ef),file=paste(acc[i], &quot;.gb&quot;, sep=&quot;&quot;)) Sys.sleep(1) cat(i, &quot;/&quot;, length(acc), &quot;\\n&quot;);flush.console() } 12.1 Genbank data parsing 다운로드 받은 파일을 열어 Genbank 포맷의 데이터를 보면 다음과 같이 Locus, Definition 에서부터 시작하여 Feature 까지 다양한 서열에 관한 정보들이 같이 들어 있습니다. 그러나 이러한 정보는 단지 text 파일에 나열된 문자열에 불과합니다. 필요한 정보를 특정 변수에 넣고 이를 필요할 때 언제든 참조해서 사용할 수 있도록 해 두는 것이 좋으며 이러한 작업을 parsing이라고 합니다. genbank Genbank 데이터의 파싱은 genbankr이라는 패키지를 사용해서 구현할 수 있습니다. 다음 코드를 이용해서 다운로드받은 첫 번째 뎅기바이러스의 genbank파일을 파싱할 수 있습니다. library(genbankr) acc &lt;- c(&quot;NC_001477&quot;, &quot;NC_001474&quot;, &quot;NC_001475&quot;, &quot;NC_002640&quot;) acc_files &lt;- paste(acc, &quot;.gb&quot;, sep=&quot;&quot;) dg_list &lt;- vector(&quot;list&quot;, length(acc_files)) dg_list[[1]] &lt;- parseGenBank(file = acc_files[1]) ## Warning in fill_stack_df(resthang$FEATURES[typs == &quot;source&quot;]): Got ## unexpected multi-value field(s) [ type ]. The resulting column(s) will ## be of class CharacterList, rather than vector(s). Please contact the ## maintainer if multi-valuedness is expected/meaningful for the listed ## field(s). str(dg_list[[1]]) ## List of 11 ## $ LOCUS : chr &quot;LOCUS NC_001477 10735 bp ss-RNA linear VRL 03-MAY-2019&quot; ## $ FEATURES :List of 37 ## ..$ 1 :&#39;data.frame&#39;: 1 obs. of 11 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 1 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;source&quot; ## .. ..$ organism: chr &quot;Dengue virus 1&quot; ## .. ..$ mol_type: chr &quot;genomic RNA&quot; ## .. ..$ db_xref : chr &quot;taxon:11053&quot; ## .. ..$ clone : chr &quot;45AZ5&quot; ## .. ..$ type.1 : chr &quot;1&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 2 :&#39;data.frame&#39;: 1 obs. of 6 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 1 ## .. ..$ end : int 94 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;5&#39;UTR&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 3 :&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 2 ## .. ..$ end : int 69 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;stem-loop A (SLA)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 4 :&#39;data.frame&#39;: 1 obs. of 8 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 70 ## .. ..$ end : int 78 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;regulatory&quot; ## .. ..$ regulatory_class: chr &quot;other&quot; ## .. ..$ note : chr &quot;oligo U track spacer&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 5 :&#39;data.frame&#39;: 1 obs. of 8 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 79 ## .. ..$ end : int 94 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;regulatory&quot; ## .. ..$ regulatory_class: chr &quot;promoter&quot; ## .. ..$ note : chr &quot;5&#39; upstream AUG region (UAR)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 6 :&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 79 ## .. ..$ end : int 93 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;stem-loop B (SLB)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 7 :&#39;data.frame&#39;: 1 obs. of 10 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 95 ## .. ..$ end : int 10273 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;gene&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ db_xref : chr &quot;GeneID:5075725&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 8 :&#39;data.frame&#39;: 1 obs. of 14 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 95 ## .. ..$ end : int 10273 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;CDS&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ codon_start : num 1 ## .. ..$ product : chr &quot;polyprotein&quot; ## .. ..$ protein_id : chr &quot;NP_059433.1&quot; ## .. ..$ db_xref : chr &quot;GeneID:5075725&quot; ## .. ..$ translation : chr &quot;MNNQRKKTGRPSFNMLKRARNRVSTVSQLAKRFSKGLLSGQGPMKLVMAFIAFLRFLAIPPTAGILARWGSFKKNGAIKVLRGFKKEISNMLNIMNRRKRSVTMLLMLLPT&quot;| __truncated__ ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 9 :&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 95 ## .. ..$ end : int 436 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;anchored capsid protein ancC&quot; ## .. ..$ protein_id : chr &quot;NP_722457.2&quot; ## .. ..$ db_xref : chr &quot;VBRC:35735&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 10:&#39;data.frame&#39;: 1 obs. of 13 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 95 ## .. ..$ end : int 394 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;capsid protein C&quot; ## .. ..$ note : chr &quot;added by NCBI staff following more recentannotations of this virus sequence&quot; ## .. ..$ protein_id : chr &quot;NP_722466.2&quot; ## .. ..$ db_xref : chr &quot;VBRC:67793&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 11:&#39;data.frame&#39;: 1 obs. of 11 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 437 ## .. ..$ end : int 934 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;membrane glycoprotein precursor prM&quot; ## .. ..$ protein_id : chr &quot;NP_733807.2&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 12:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 437 ## .. ..$ end : int 709 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;protein pr&quot; ## .. ..$ note : chr &quot;peptide pr&quot; ## .. ..$ protein_id : chr &quot;YP_009164956.1&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 13:&#39;data.frame&#39;: 1 obs. of 11 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 710 ## .. ..$ end : int 934 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;membrane glycoprotein M&quot; ## .. ..$ protein_id : chr &quot;NP_722459.2&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 14:&#39;data.frame&#39;: 1 obs. of 11 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 935 ## .. ..$ end : int 2419 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;envelope protein E&quot; ## .. ..$ protein_id : chr &quot;NP_722460.2&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 15:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 2420 ## .. ..$ end : int 3475 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;nonstructural protein NS1&quot; ## .. ..$ protein_id : chr &quot;NP_722461.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35739&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 16:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 3476 ## .. ..$ end : int 4129 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;nonstructural protein NS2A&quot; ## .. ..$ protein_id : chr &quot;NP_733808.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35740&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 17:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 4130 ## .. ..$ end : int 4519 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;nonstructural protein NS2B&quot; ## .. ..$ protein_id : chr &quot;NP_733809.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35741&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 18:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 4520 ## .. ..$ end : int 6376 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;nonstructural protein NS3&quot; ## .. ..$ protein_id : chr &quot;NP_722463.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35742&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 19:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 6377 ## .. ..$ end : int 6757 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;nonstructural protein NS4A&quot; ## .. ..$ protein_id : chr &quot;NP_733810.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35743&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 20:&#39;data.frame&#39;: 1 obs. of 13 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 6758 ## .. ..$ end : int 6826 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;protein 2K&quot; ## .. ..$ note : chr &quot;added by NCBI staff following more recentannotations of this virus sequence&quot; ## .. ..$ protein_id : chr &quot;NP_722467.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:67794&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 21:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 6827 ## .. ..$ end : int 7573 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;nonstructural protein NS4B&quot; ## .. ..$ protein_id : chr &quot;NP_733811.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35744&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 22:&#39;data.frame&#39;: 1 obs. of 12 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 7574 ## .. ..$ end : int 10270 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;mat_peptide&quot; ## .. ..$ gene : chr &quot;POLY&quot; ## .. ..$ locus_tag : chr &quot;DV1_gp1&quot; ## .. ..$ gene_synonym: chr &quot;polyprotein gene&quot; ## .. ..$ product : chr &quot;RNA-dependent RNA polymerase NS5&quot; ## .. ..$ protein_id : chr &quot;NP_722465.1&quot; ## .. ..$ db_xref : chr &quot;VBRC:35745&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 23:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 114 ## .. ..$ end : int 130 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;capsid region hairpin (cHP)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 24:&#39;data.frame&#39;: 1 obs. of 8 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 132 ## .. ..$ end : int 142 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;regulatory&quot; ## .. ..$ regulatory_class: chr &quot;other&quot; ## .. ..$ note : chr &quot;5&#39; conserved sequence (CS); also called cyclizationsequence&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 25:&#39;data.frame&#39;: 1 obs. of 6 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10274 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;3&#39;UTR&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 26:&#39;data.frame&#39;: 1 obs. of 9 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10320 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;ncRNA&quot; ## .. ..$ ncRNA_class: chr &quot;lncRNA&quot; ## .. ..$ product : chr &quot;sfRNA1&quot; ## .. ..$ note : chr &quot;subgenomic flavivirus RNA&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 27:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10324 ## .. ..$ end : int 10389 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;flaviviral nuclease-resistant RNA 1 (fNR1); alsocalled stem-loop 1 or xrRNA1&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 28:&#39;data.frame&#39;: 1 obs. of 9 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10393 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;ncRNA&quot; ## .. ..$ ncRNA_class: chr &quot;lncRNA&quot; ## .. ..$ product : chr &quot;sfRNA2&quot; ## .. ..$ note : chr &quot;subgenomic flavivirus RNA&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 29:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10397 ## .. ..$ end : int 10458 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;flaviviral nuclease-resistant RNA 2 (fNR2); alsocalled stem-loop 2 or xrRNA2&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 30:&#39;data.frame&#39;: 1 obs. of 9 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10463 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;ncRNA&quot; ## .. ..$ ncRNA_class: chr &quot;lncRNA&quot; ## .. ..$ product : chr &quot;sfRNA3&quot; ## .. ..$ note : chr &quot;subgenomic flavivirus RNA&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 31:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10467 ## .. ..$ end : int 10549 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;dumbbell 1 (DBI); also called xrRNA3&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 32:&#39;data.frame&#39;: 1 obs. of 9 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10551 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;ncRNA&quot; ## .. ..$ ncRNA_class: chr &quot;lncRNA&quot; ## .. ..$ product : chr &quot;sfRNA4&quot; ## .. ..$ note : chr &quot;subgenomic flavivirus RNA&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 33:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10551 ## .. ..$ end : int 10633 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;dumbbell 2 (DBII); also called xrRNA4&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 34:&#39;data.frame&#39;: 1 obs. of 8 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10630 ## .. ..$ end : int 10640 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;regulatory&quot; ## .. ..$ regulatory_class: chr &quot;other&quot; ## .. ..$ note : chr &quot;3&#39; conserved sequence (CS); also called cyclizationsequence&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 35:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10643 ## .. ..$ end : int 10656 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;short hairpin (sHP)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 36:&#39;data.frame&#39;: 1 obs. of 8 variables: ## .. ..$ seqnames : chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10654 ## .. ..$ end : int 10670 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;regulatory&quot; ## .. ..$ regulatory_class: chr &quot;promoter&quot; ## .. ..$ note : chr &quot;3&#39; upstream AUG region (UAR)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..$ 37:&#39;data.frame&#39;: 1 obs. of 7 variables: ## .. ..$ seqnames: chr &quot;Dengue virus 1&quot; ## .. ..$ start : int 10657 ## .. ..$ end : int 10735 ## .. ..$ strand : chr &quot;+&quot; ## .. ..$ type : chr &quot;stem_loop&quot; ## .. ..$ note : chr &quot;3&#39; stem-loop (3&#39;SL)&quot; ## .. ..$ loctype : chr &quot;normal&quot; ## ..- attr(*, &quot;dim&quot;)= int 37 ## ..- attr(*, &quot;dimnames&quot;)=List of 1 ## .. ..$ : chr [1:37] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ ORIGIN :Formal class &#39;DNAStringSet&#39; [package &quot;Biostrings&quot;] with 5 slots ## .. ..@ pool :Formal class &#39;SharedRaw_Pool&#39; [package &quot;XVector&quot;] with 2 slots ## .. .. .. ..@ xp_list :List of 1 ## .. .. .. .. ..$ :&lt;externalptr&gt; ## .. .. .. ..@ .link_to_cached_object_list:List of 1 ## .. .. .. .. ..$ :&lt;environment: 0x000000000855aae0&gt; ## .. ..@ ranges :Formal class &#39;GroupedIRanges&#39; [package &quot;XVector&quot;] with 7 slots ## .. .. .. ..@ group : int 1 ## .. .. .. ..@ start : int 1 ## .. .. .. ..@ width : int 10735 ## .. .. .. ..@ NAMES : chr &quot;Dengue virus 1&quot; ## .. .. .. ..@ elementType : chr &quot;ANY&quot; ## .. .. .. ..@ elementMetadata: NULL ## .. .. .. ..@ metadata : list() ## .. ..@ elementType : chr &quot;DNAString&quot; ## .. ..@ elementMetadata: NULL ## .. ..@ metadata : list() ## $ ACCESSION : chr &quot;NC_001477&quot; ## $ COMMENT : NULL ## $ DBLINK : NULL ## $ DEFINITION: chr &quot;Dengue virus 1, complete genome.&quot; ## $ KEYWORDS : chr &quot;RefSeq.&quot; ## $ REFERENCE : NULL ## $ SOURCE :List of 3 ## ..$ source : chr &quot;Dengue virus 1&quot; ## ..$ organism: chr &quot;Dengue virus 1&quot; ## ..$ lineage : chr [1:4] &quot; Viruses&quot; &quot;Riboviria&quot; &quot;Flaviviridae&quot; &quot;Flavivirus.&quot; ## $ VERSION : Named chr [1:2] &quot;NC_001477.1&quot; NA ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;accession.version&quot; &quot;GenInfoID&quot; 위 파싱된 파일의 구조를 보면 37개의 feature가 있고 각 feature에 대해서 7 또는 8개의 variable로 이루어진 것을 알 수 있습니다. 즉, dg_list가 4개 길이를 갖는 list형태의 변수이고 4개 각각의 저장된 변수가 다시 또 list 형태의 변수이고 그 안에 여러개의 feature가 data.frame 형식의 변수로 저장이 되어 있는 형태 입니다. 예를 들어 37번째 feature의 start position을 알고 싶을 때 dg_list[[1]]$FEATURES[[37]]$start 이와 같이 실행하면 원하는 값이 출력됩니다. 12.1.1 Exercise 11-1 앞서 파싱 코드는 첫 번째 파일에 대해서만 수행되었습니다. 이를 for문을 이용하여 4개 파일 모두에 대해서 파싱 작업을 수행합니다. 프로그램밍에서 for문의 사용은 R 언어뿐만 아니라 다른 여러 언어에서도 기본이 되는 문법으로 그 사용법은 필수로 숙지하고 있어야 합니다. for 문과 i 인덱스를 사용하는 부분을 특히 참고하시기 바랍니다. acc &lt;- c(&quot;NC_001477&quot;, &quot;NC_001474&quot;, &quot;NC_001475&quot;, &quot;NC_002640&quot;) acc_files &lt;- paste(acc, &quot;.gb&quot;, sep=&quot;&quot;) dg_list &lt;- vector(&quot;list&quot;, length(acc_files)) for(i in 1:length(acc)){ dg_list[[i]] &lt;- parseGenBank(file = acc_files[i]) } 12.2 IRanges for genome view 앞서 보여드린 바와 같이 genbank 데이터의 내용 중 대부분을 차지하는 정보는 전체 지놈 서열 중 어디서 어디까지가 유전자 또는 coding sequence 이고 그 번역된 정보가 무엇인지 설명하는 정보 입니다. 즉, feature 정보가 genbank 데이터의 대부분을 차지한다고 해도 과언이 아니며 이러한 feature 정보를 보는 것이 곧 지놈을 분석하기 위한 필수 조건이라고 해도 과언이 아닙니다. 따라서 genbank의 feature 정보를 효율적으로 가시화 하기위한 방법들이 다양하게 개발되어 왔으며 R에서는 IRanges와 GenomicRanges 라는 패키지를 사용할 수 있습니다. 12.2.1 Exercise 11-2 지놈 가시화에서 각 구간(Feature)에 해당하는 CDS 는 사각형으로 그리는 것이 보통입니다. 따라서 IRanges 를 사용하기 전에 사각형을 그리는 예제를 수행하면서 feature를 어떻게 표현할 수 있는이 먼저 이해해 보도록 하겠습니다. 사각형은 기본적으로 4개의 좌표가 있으면 그릴 수 있는 도형입니다. Rect 위와 같은 사각형은 기본 R 그래픽 함수를 이용해서 사각형을 그릴 수 있습니다. plot.new()함수는 빈 켄버스를 그리고 plot.window() 함수는 x, y 축의 범위 등을 지정하며 이 후 rect, axis 등을 이용해서 사각형이나 x, y 축을 그려줍니다. plot.new() plot.window(xlim=c(0,2), ylim=c(0,2)) rect(0,0,1,1) axis(1) axis(2) 이러한 사각형의 연속된 표현으로 지놈상의 CDS를 표현해 주며 사각형 정보를 담고 있는 변수는 IRanges를 이용해서 만들 수 있습니다. IRanges 함수는 start와 end를 매개변수로 받으며 각각 vector 형으로 vector 길이 만큼의 start, end 짝이 생성되어 하나의 변수에 저장됩니다. 다음 코드를 실행하면서 좀 더 쉽게 이해 하실 수 있습니다. library(IRanges) ir &lt;- IRanges(start=c(1,3,12,10), end=c(4,5,25,19)) ir length(ir) start(ir) end(ir) width(ir) range(ir) 이제 앞서 배운 사각형 그리는 방법을 이용해서 위 IRanges로 만든 각각의 구간을 그려보도록 하겠습니다. 모든 구간은 start 부터 end 까지 주어져 있고 각 구간의 높이를 1로 고정한다면 사각형을 그리기 위한 네 점을 모두 구할 수 있습니다. 한 가지 주의를 요하는 부분은 각 CDS의 구간이 서로 독립적이지 않고 서로 겹쳐져서 나타날 수 있습니다. 이 때 겹치는 부분이 있을 경우 사각형을 한 칸 위로 위치시켜서 그리면 모든 CDS를 명확히 구분되게 그릴 수 있습니다. ir &lt;- IRanges(start=c(1,3,12,10), end=c(4,5,25,19)) height &lt;- 1 xlim = c(min(start(ir)), max(end(ir))) bins = disjointBins(ir) plot.new() plot.window(xlim, c(0, max(bins) * height)) ybottom = bins * height - height rect(start(ir), ybottom, end(ir), ybottom + height, col = &quot;blue&quot;) axis(1) 이제 동일한 기능을 기본 그래프 함수가 아닌 ggplot을 이용해서 수행해 보겠습니다. ggplot은 앞에서 배운 것처럼 plot 정보를 저장한 data.frame형 변수를 만들고 aes로 해당 데이터와 필요 파라메터들을 mapping해준 후 적절한 geometry 함수와 stat을 이용해서 그림을 그리게 됩니다. 본 예제에서는 geom_rect라는 geometry 함수를 사용하면 되겠으며 geom_rect 함수의 필요 파라메터는 사각형을 그리기 위해서 필요한 (xmin, xmax, ymin and ymax) 네 가지 값을 전달해주면 됩니다. 즉, aes 함수에서 이 네 개 파라메터에 맞는 데이터를 mapping 해 주면 되며 이를 위해서 data.frame 또한 위 네 개 값을 갖도록 만들어 주면 되겠습니다. 대략적인 코드는 다음과 같습니다. ir &lt;- IRanges(start=c(1,3,12,10), end=c(4,5,25,19)) height &lt;- 1 bins &lt;- disjointBins(ir) ybottom &lt;- bins*height - height df &lt;- data.frame(ybottom = ybottom, xleft = start(ir), xright = end(ir), ytop = ybottom + height) ggplot(df, aes(xmax = xright, xmin = xleft, ymax = ytop, ymin = ybottom)) + geom_rect() 12.2.2 Exercise 11-3 위와 같이 생성한 IRanges 타입 변수의 정보를 그리기 위해서는 1) df 라는 각 사각형의 위치 정보를 갖는 데이터프레임을 생성하고 2) ggplot을 이용해서 적절히 그려주는 (크게) 두 가지 일을 수행해야 합니다. 그런데 새로운 ir 만들 때마다 위 두 가지를 수행하는 코드를 작성하기 보다는 하나의 함수로 만들어서 사용하면 효율을 높일 수 있습니다. 다음 코드에 위 두 가지 일을 수행하는 plotRanges라는 함수를 만들었습니다. plotRanges &lt;- function(ir, height=1, sep=0.5){ xm &lt;- c(min(start(ir))-sep, max(end(ir))+sep) bins &lt;- disjointBins(ir) ybottom &lt;- bins*(sep+height) - height df &lt;- data.frame(ybottom = ybottom, xleft = start(ir) - sep, xright = end(ir) + sep, ytop = ybottom + height) ggplot(df, aes(xmax = xright, xmin = xleft, ymax = ytop, ymin = ybottom)) + geom_rect() } 이제 IRanges 변수를 만든 후 위 함수를 다음과 같이 간단히 사용할 수 있습니다. ir &lt;- IRanges(start=c(1,3,12,10), end=c(4,5,25,19)) plotRanges(ir) 12.3 Feature view using IRanges and ggplot2 이제 앞서 읽어온 실제 뎅기바이러스 지놈 데이터로부터 feature를 읽고 이를 visualization 하는 실습을 하겠습니다. 먼저 리스트에 저장된 네 개의 뎅기 바이러스 genbank 정보를 하나의 변수 (sel_dg)에 옮기고 각 정보들을 확인해 봅니다. 이 후 for문을 이용해서 모든 feature 들에 대해 start와 end 정보를 읽어 옵니다. sel_dg &lt;- dg_list[[1]] #sel_dg$FEATURES[[1]]$type #sel_dg$FEATURES[[1]]$start #sel_dg$FEATURES[[1]]$end #sel_dg$FEATURES[[1]]$strand #sel_dg$FEATURES[[1]]$product n &lt;- length(sel_dg$FEATURES) start.pos &lt;- rep(0, n) end.pos &lt;- rep(0, n) for(i in 1:n){ start.pos[i] &lt;- sel_dg$FEATURES[[i]]$start end.pos[i] &lt;- sel_dg$FEATURES[[i]]$end } 그리고 위 읽어들인 feature들의 정보를 IRanges 함수로 구간별 정보를 갖는 ir 변수를 만들고 앞서 만든 plotRanges()라는 함수를 이용하여 각 구간을 그려 보도록 하겠습니다. ir &lt;- IRanges(start=start.pos, end=end.pos) plotRanges(ir) 12.3.1 Exercise 11-4 그런데 위 그림에서는 feature 정보들이 눈에 띄게 들어오지 않습니다. 이는 두 가지 문제가 원인으로 볼 수 있습니다. 하나는 feature들이 같은 색이기 때문에 구분되지 않는 상황과 또 하나는 다양한 type의 feature가 있기 때문에 우리가 보고싶은 feature만 따로 빼내기 전에는 많은 정보들이 혼재되어 보일 수 있다는 점 입니다. 이를 위해 우리는 feature type이 “mat_peptide” (즉, 성숙한 팹타이드?) 만을 골라서 그림을 그려보도록 하겠습니다. 조건문을 실행하기 위해서는 if를 사용할 수 있습니다. 또한 앞서 코드와는 다르게 for문을 반복하면서 vector를 하나씩 늘려가는 방법으로 값을 저장하겠습니다. sel_dg &lt;- dg_list[[1]] n &lt;- length(sel_dg$FEATURES) start_pos &lt;- c() end_pos &lt;- c() for(i in 1:n){ if(sel_dg$FEATURES[[i]]$type==&quot;mat_peptide&quot;){ start_pos &lt;- c(start_pos, sel_dg$FEATURES[[i]]$start) end_pos &lt;- c(end_pos, sel_dg$FEATURES[[i]]$end) } } ir &lt;- IRanges(start=start_pos, end=end_pos) plotRanges(ir) 우리가 필요한 feature 만을 뽑아서 본 그림 입니다. 그러나 총 feature 의 갯수는 13개인데 여전히 구분이 되지 않고 있습니다. 이는 앞서 언급한 문제점 중 첫번째 문제점 때문에 발생하는 상황입니다. 이를 위해 다음과 같이 임의로 group을 나누어 주고 각 그룹에 대해서 다른 색을 그리도혹 ggplot의 명령을 바꾸어 주면 기대한 것 처럼 각 feature들 구분할 수 있습니다. ir &lt;- IRanges(start_pos, end_pos) bins &lt;- disjointBins(ir) df &lt;- data.frame(ybottom = bins, xleft = start(ir), xright = end(ir), ytop = bins + 1, group_no = LETTERS[1:length(ir)]) ggplot(df, aes(xmax = xright, xmin = xleft, ymax = ytop, ymin = ybottom, fill = group_no)) + geom_rect() IRanges는 특정 CDS 구간에 대한 범위 정보만을 가지고 있는 데이터 타입입니다. 그러나 해당 위치의 locus 또는 유전자 이름이나 단백질 정보 등 해당 서열에 해당하는 많은 유전학적 정보들이 있을 수 있습니다. GenomicRanges는 IRanges를 포함하여 위 정보들을 모두 다룰 수 있는 패키지 입니다. 다음 시간에는 위 GenomicRanges를 간단히만 설명하고 서열 비교 등에 관한 내용을 학습하도록 하겠습니다. "],
["lecture-12-sequence-analysis-in-r-iii.html", "13 Lecture 12 - Sequence analysis in R III", " 13 Lecture 12 - Sequence analysis in R III 강의 노트 [Lecture note] R을 이용한 서열분석 세 번째 시간입니다. 지난 두 시간동안 NCBI 데이터를 활용하기 위한 reutils 패키지 사용법과 genbank 파일을 파싱하고 그 안에 있는 feature 를 visualization 하는 방법을 배웠습니다. 이번 시간에는 NCBI에서 특정 서열들을 다운받아 이들의 alignment 와 visualization 등에 관한 내용을 강의하도록 하겠습니다. 필요한 패키지들은 대략 다음과 같습니다. Biostrings DECIPER dplyr 등.. 실습 데이터 다운로드 gene_results.txt fasta zip file "]
]
