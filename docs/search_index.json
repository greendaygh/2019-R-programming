[
["index.html", "[2019 UST 일반강의] R 프로그래밍과 데이터 분석 1 Lecture 개요 1.1 Goal 강의 목표 1.2 References 참고 자료 1.3 Evaluation 평가 세부 항목 1.4 Schedule 강의 계획 1.5 Lecture note 강의 자료", " [2019 UST 일반강의] R 프로그래밍과 데이터 분석 Haseong Kim 2019-04-10 1 Lecture 개요 장소: 한국생명공학연구원 연구동 세미나실 1213호 (매주수요일 13:00~16:00) 강사: 한국생명공학연구원 바이오합성연구센터 김하성 연락처: 042-860-4372, haseong@kribb.re.kr (생명연 연구동 1143) homepage: https://greendaygh.github.io/Rprog2019/ https://github.com/greendaygh/Rprog2019 1.1 Goal 강의 목표 이공계열 대학원생이 통계 분석용 범용 프로그램 언어인 R의 사용법을 익히고 이를 이용한 프로그래밍 기술의 습득을 주요 목적으로 함. 생물 데이터 위주의 분석 예제를 통해 R의 활용 기술을 배움. 이 강좌는 오프라인 강의를 기본으로 함. R 사용에 대한 기본 개념과 프로그래밍을 중심으로 필요시 기초 통계지식 강의. 실습 데이터로는 주로 생물데이터를 사용함. 모든 강의 시간 실습을 위한 개인 노트북 지참 필수. 강의 자료는 pdf로 제작하여 수업 진행과 관련된 정보와 함께 웹사이트를 통해 배포됨. 상황에 따라 강의 일정이 조정될 수 있음. 1.2 References 참고 자료 R for Data Science (https://r4ds.had.co.nz, https://github.com/hadley) Using R for Introductory Statistics by John Verzani Free version of 1st Edition https://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf http://cbb.sjtu.edu.cn/~mywu/bi217/usingR.pdf Second edition https://www.crcpress.com/Using-R-for-Introductory-Statistics-Second-Edition/Verzani/p/book/9781466590731 Bioinformatics Data Skills by Vince Buffalo https://resources.rstudio.com/ 일반통계학 (영지문화사, 김우철 외) 1.3 Evaluation 평가 세부 항목 출석 50% / 과제 50% / 수업참여 +alpha 1.4 Schedule 강의 계획 Introduction and installation of R/Rstudio R language basics Data manipulation Visualizing data in R Shiny for interactive applications in R Workflows with R scripts Working with Range Data Sequence analysis Clustering and significance testing with genomic data 1.5 Lecture note 강의 자료 1 (2019.03.06) - Introduction and installation of R/Rstudio, Basics of variables and functions 2 (2019.03.13) - R Basics - Objects (vector, factor, matrix) and functions 다음 시간 readxl, Biostrings 두 패키지 미리 설치한 후 강의 참석 부탁드립니다. 3 (2019.03.20) - R Basics II - file I/O 강의가 좀 빠르게 진행된 듯 합니다. 기본으로 제공되는 R 기능을 사용하기 보다는 함수나 프로그래밍 코딩 원리를 이해하기 위해 직접 함수를 만들어보는 연습을 하고 있으니 참고 하시고 다음 시간 전에 이번 시간 코드 복습하시고 오시면 도움이 되실 것 같습니다. 4 (2019.03.27) - R programming example - Maze Robot 5 (2019.04.03) - R programming example - Plate reader "],
["lecture-01-r-introduction.html", "2 Lecture 01 - R Introduction", " 2 Lecture 01 - R Introduction "],
["lecture-02-r-basics-i.html", "3 Lecture 02 - R basics I 3.1 exercise 2-1: who function", " 3 Lecture 02 - R basics I 3.1 exercise 2-1: who function 함수를 만들고 사용하는 실습입니다. name 함수를 이용하여 벡터 값들에 대한 이름을 할당할 수 있으며 who 라는 이름의 함수를 생성하여 input 파라메터의 값 중 50 이상의 사람들에 대한 인덱스를 얻고 (which), 이들의 ages &lt;- c(21, 55, 23, 53) names(ages) &lt;- c(&quot;John&quot;,&quot;James&quot;,&quot;Sara&quot;, &quot;Lilly&quot;) who &lt;- function(input){ greater_than_fifty_index &lt;- which(input &gt; 50) greater_numbers &lt;- input[greater_than_fifty_index] greater_names &lt;- names(greater_numbers) return(greater_names) } who(ages) ## [1] &quot;James&quot; &quot;Lilly&quot; "],
["lecture-03-r-basics-ii.html", "4 Lecture 03 - R Basics II 4.1 matrix (행렬) 4.2 data.frame 4.3 list 4.4 File 읽기/쓰기 4.5 Excel file 읽기/쓰기 4.6 Exercise 3-2 standard deviation 4.7 Exercise 3-3 barplot with error bars", " 4 Lecture 03 - R Basics II 4.1 matrix (행렬) 매트릭스는 2차원 행렬로 같은 형식의 데이터 값 (numberic, character, logical) 으로만 채워진 행렬을 말합니다. 메트릭스를 만드는 방법은 아래와 같으며 nrow와 ncol 파라메터에 행과 열의 수를 넣고 각 셀에 들어갈 값은 가장 앞에 위치한 data 파라메터에 넣어 줍니다 (?matrix로 파라메터 이름 확인). 메트릭스 인덱싱은 메트릭스 안의 값을 저장하거나 참조할때 (빼올때) 사용하는 방법입니다. 메트릭스 변수이름 바로 뒤에 대괄호를 이용해서 제어를 하며 대괄호 안에 콤마로 구분된 앞쪽은 row, 뒷쪽은 column 인덱스를 나타냅니다. row 또는 column에 해당하는 어느쪽에도 값을 넣지 않을 경우 그 row 또는 column 전체를 참조하게 됩니다. mymat &lt;- matrix(0, nrow=100, ncol=3) # 1 mymat[,1] &lt;- 1:100 # 2 mymat[,2] &lt;- seq(1,200,2) # 3 mymat[,3] &lt;- seq(2,200,2) # 4 여러 row나 column을 참조할 경우 아래와 같이 combine 함수를 사용하여 묶어줘야 하며 스칼라값을 더하거나 뺄 경우 vector / matrix 연산을 기본으로 수행합니다. mymat[c(2,3,4,5),2] # 5 mymat-1 # 6 mysub &lt;- mymat[,2] - mymat[,1] #7 sum(mysub) #8 sum(mysub^2) #8 4.2 data.frame 데이터프레임은 변수의 모임으로 형태는 매트릭스와 같으나 $ 기호를 이용하여 각 구성 변수를 참조할 수 있다는 점이 다릅니다. 또한 데이터프레임 또는 매트릭스의 row나 column에 이름이 주어져 있을 경우 이름을 따옴표(“)로 묶은 후 참조가 가능합니다. ## data.frame ids &lt;- 1:10 ids idnames &lt;- paste(&quot;Name&quot;, ids, sep=&quot;&quot;) idnames students &lt;- data.frame(ids, idnames) students class(students$ids) class(students$idnames) students$idnames students &lt;- data.frame(ids, idnames, stringsAsFactors = F) class(students$idnames) students$idnames students[1,] ## data frame indexing students$ids students[,1] students[,&quot;ids&quot;] 4.3 list 리스트는 변수들의 모임이라는 점에서 데이터프레임과 같으나 구성 변수들의 길이가 모두 같아야 하는 데이터프레임과는 달리 다른 길이의 변수를 모아둘 수 있는 점이 다릅니다. 리스트는 아래와 같이 대괄호 두 겹을 이용해 인덱싱을 합니다. ## list parent_names &lt;- c(&quot;Fred&quot;, &quot;Mary&quot;) number_of_children &lt;- 2 child_ages &lt;- c(4, 7, 9) data.frame(parent_names, number_of_children, child_ages) lst &lt;- list(parent_names, number_of_children, child_ages) lst[1] lst[[1]] class(lst[1]) class(lst[[1]]) lst[[1]][1] lst[[1]][c(1,2)] 4.4 File 읽기/쓰기 텍스트 파일의 경우 아래와 같이 csv 또는 txt 파일로 저장하여 메모장으로 열어 확인할 수 있으며 읽어올 경우 구분자 (sep 파라메터) 나 header를 (header 파라메터) 읽을지 읽지 않을지 등을 옵션으로 지정할 수 있습니다. x &lt;- c(1,2,3,4) y &lt;- c(5,6,7,8) xy&lt;-data.frame(x=x, y=y) write.table(xy, file=&quot;table_write.txt&quot;) write.table(xy, file=&quot;table_write.txt&quot;, quote=F) write.table(xy, file=&quot;table_write.txt&quot;, quote=F, row.names=F) write.table(xy, file=&quot;table_write.txt&quot;, quote=F, row.names=F, sep=&quot;,&quot;) write.table(xy, file=&quot;table_write.csv&quot;, quote=F, row.names=F, sep=&quot;,&quot;) mydata&lt;-read.table(file=&quot;table_write.csv&quot;) mydata&lt;-read.table(file=&quot;table_write.csv&quot;, sep=&quot;,&quot;) mydata&lt;-read.table(file=&quot;table_write.csv&quot;, sep=&quot;,&quot;, header=T) plot(mydata$x, mydata$z) 4.5 Excel file 읽기/쓰기 엑셀파일은 readxl 이라는 R 패키지를 활용하여 읽거나 쓸 수 있습니다. install.packages(&quot;readxl&quot;) 실습 파일은 형광 세포를 배양하여 형광리더기를 이용해 얻어진 실제 데이터이며 Rprog04-fl.xls 에서 다운로드 받을 수 있습니다. read_excel 함수를 이용하여 파일의 내용을 읽어오면 기본 자료형이 tibble 입니다. tibble은 최근 많이 쓰이는 R object로 data.frame과 유사하나 입력값의 type, name, rowname을 임으로 바꿀 수 없다는 점이 다릅니다. tibble에 익숙해지는 것이 좋으나 본 강의에서는 직관적인 진행을 위하여 data.frame으로 전환하여 사용하겠습니다. library(readxl) ## Warning: package &#39;readxl&#39; was built under R version 3.5.3 mydata &lt;- read_excel(&quot;Rprog04-fl.xls&quot;, sheet=2, skip = 6, col_names=F) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems myod &lt;- as.data.frame(mydata[1:8, ]) mygfp &lt;- as.data.frame(mydata[12:21, ]) class(myod[,1]) class(myod[,2]) 엑셀파일에는 두 종류의 (OD600nm, fluorescence) 데이터가 저장되어 있으며 각각을 위에서 1~8 row 그리고 12~21 row 값들을 모두 myod와 mygfp로 저장했습니다. 그러나 엑셀파일을 보면 첫번째 컬럼에 관측값 외에 다른 정보들에 대한 텍스트가 적혀 있으며 이로 인해 행렬의 가장 첫 컬럼의 데이터 타입이 character가 되고 나머지 컬럼은 numeric으로 자동 전환 되어 data.frame 오브젝트인 mydata에 저장되게 됩니다. 따라서 아래와 같이 문자형을 숫자형으로 전환하여 추후 연산을 진행하게 됩니다. myod[,1] &lt;- as.numeric(myod[,1]) mygfp[,1] &lt;- as.numeric(mygfp[,1]) 수행한 실험의 디자인에 따라서 두 그룹으로 나누고 적절한 이름을 저장합니다. myod_treat &lt;- myod[2:4,] myod_control &lt;- myod[5:7,] sample_names &lt;- paste(&quot;Sample&quot;, c(1:12), sep=&quot;&quot;) replicate_labels &lt;- paste(&quot;Rep&quot;, c(1:3), sep=&quot;&quot;) rownames(myod_treat) &lt;- replicate_labels colnames(myod_treat) &lt;- sample_names rownames(myod_control) &lt;- replicate_labels colnames(myod_control) &lt;- sample_names mean_treat &lt;- colMeans(myod_treat) mean_control &lt;- colMeans(myod_control) 위 예제의 colMean 과 같은 함수는 column 또는 row 단위로 해당하는 모든 값들에 대해 연산을 수행해주는 함수로 colMean은 평균을 계산하는 함수이고 일반적으로는 다음과 같이 apply 함수와 mean 함수를 이용해서 같은 기능을 수행할 수 있습니다. mean 함수 외 임의의 원하는 함수를 만들어 사용할 수 도 있습니다. 참고로 sd는 표준편차를 구해주는 함수 입니다. apply(myod_control, 1, mean) ## Rep1 Rep2 Rep3 ## 0.8069922 0.7706701 0.7873404 apply(myod_control, 2, mean) ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 Sample7 ## 0.7757480 0.7807732 0.7628736 0.7472908 0.7034527 0.6963549 0.8094640 ## Sample8 Sample9 Sample10 Sample11 Sample12 ## 0.8145531 0.8301742 0.8390556 0.8447189 0.8555517 apply(myod_control, 2, function(x){ xmean &lt;- mean(x) return(xmean) }) ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 Sample7 ## 0.7757480 0.7807732 0.7628736 0.7472908 0.7034527 0.6963549 0.8094640 ## Sample8 Sample9 Sample10 Sample11 Sample12 ## 0.8145531 0.8301742 0.8390556 0.8447189 0.8555517 apply(myod_control, 2, sd) ## Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 ## 0.015981356 0.023394455 0.032168135 0.034528460 0.035805916 0.014999636 ## Sample7 Sample8 Sample9 Sample10 Sample11 Sample12 ## 0.017801936 0.017947840 0.010253370 0.006202754 0.022386592 0.012685731 본 실습에서는 각 그룹의 평균을 비교하는 막대그래프를 그려보겠습니다. plot(mean_treat, type=&quot;h&quot;) barplot(mean_treat, ylim=c(0,1)) mean_test &lt;- data.frame(mean_treat, mean_control) barplot(t(mean_test), ylim=c(0,1), beside=T) 4.6 Exercise 3-2 standard deviation 앞서 사용한 sd 함수는 표준편차를 구해주는 기본 제공 함수입니다. 아래는 같은 기능을 하는 함수를 만들어 보는 실습 예제 입니다. ## excercise 3-2 mysd &lt;- function(x){ xmean &lt;- sum(x)/length(x) tmpdif &lt;- x-xmean xvar &lt;- sum(tmpdif^2)/(length(x)-1) xsd &lt;- sqrt(xvar) return(xsd) } x &lt;- sample(1:100, 10) mysd(x) ## [1] 32.52025 sd(x) ## [1] 32.52025 4.7 Exercise 3-3 barplot with error bars 앞서 그려본 막대그래프에 에러바를 넣어보는 코드 입니다. 먼저 평균과 표준편차 데이터를 apply 함수를 통해 얻어내고 barplot을 수행합니다. 에러바의 경우 arrows 함수를 사용하는데 사용되는 파라메터의 입력되는 값을 바꿔서 그림을 그려보면 그 의미를 파악하는데 도움이 되겠습니다. ## Exercise 3-3) barplot with sd control_mean &lt;- apply(myod_control, 2, function(x){mean(x)}) control_sd &lt;- apply(myod_control, 2, mysd) barplot(control_mean, width=0.83, space=0.2, col=&quot;gray&quot;, ylim=c(0,1)) arrows(0.5, control_mean[1], 0.5, control_mean[1]+control_sd[1], length=0.1, angle=90) arrows(0.5, control_mean[1], 0.5, control_mean[1]-control_sd[1], length=0.1, angle=90) lab &lt;- paste(&quot;SD:&quot;, round(control_mean[1]+control_sd[1],1)) text(0.5, control_mean[1]+control_sd[1]+0.05, labels = lab) arrows(1.5, control_mean[2], 1.5, control_mean[2]+control_sd[2], length=0.1, angle=90) arrows(1.5, control_mean[2], 1.5, control_mean[2]-control_sd[2], length=0.1, angle=90) lab &lt;- paste(&quot;SD:&quot;, round(control_mean[2]+control_sd[2],1)) text(1.5, control_mean[2]+control_sd[2]+0.05, labels = lab) 그러나 위 12개의 bar 모두에 대해서 arrows 함수를 그리기 보다는 for 문을 이용한 반복 실행을 수행하는 것이 효율적 입니다. for 문의 사용 형식과 반복 횟수 그리고 반복하며 변화되는 값을 갖는 변수에 대한 의미를 파악하고 사용하는 것이 중요합니다. for문의 사용법은 강의노트 를 참고하세요. ## Exercise 3-4) barplot with sd using for barplot(control_mean, width=0.83, space=0.2, col=&quot;gray&quot;, ylim=c(0,1)) for(i in 1:length(control_mean)){ xpos &lt;- 0.5+i-1 arrows(xpos, control_mean[i], xpos, control_mean[i]+control_sd[i], length=0.1, angle=90) arrows(xpos, control_mean[i], xpos, control_mean[i]-control_sd[i], length=0.1, angle=90) lab &lt;- paste(&quot;SD:&quot;, round(control_mean[i]+control_sd[i],1)) text(xpos, control_mean[i]+control_sd[i]+0.05, labels = lab) } 마지막으로 실습 예제 3-5는 엑셀파일 이름을 argument로 받아서 파일 내용을 읽고 데이터를 두 그룹으로 나누어 평균을 계산한 후 plot까지 그려주는 함수를 만드는 실습 예제 입니다. 다음 시간에 이어서 합니다. "],
["lecture-04-maze-robot.html", "5 Lecture 04 - Maze Robot 5.1 Parameter/Argument, Global/Local 5.2 Exercise 4-1: Matrix indexing 5.3 Top-down design 5.4 Exercise 4-2: Draw world 5.5 Exercise 4-4: Generate map 5.6 Draw blocks and walls 5.7 Move one step 5.8 Sleep for delay 5.9 Move 50 steps", " 5 Lecture 04 - Maze Robot 5.1 Parameter/Argument, Global/Local 이번 시간에는 함수와 메트릭스의 사용법을 익히기 위해서 재미있는(?) 간단한 프로그램을 만들어 보겠습니다. 정사각형 격자 안에서 랜덤하게 한 칸씩 움직이며 시작 점부터 끝 점까지 가는 로봇을 구현하고 이를 시각화하는 프로그램이 되겠습니다. 먼저 프로그래밍에서 함수는 중요한 개념입니다. 이를 이해하기 위해서 parameter (매개변수) 와 argument (전달인자), 그리고 global (전역) 변수와 local (지역) 변수의 개념을 확실히 이해해야 합니다. 아래 parameter와 argument를 구분하고 myfunc 안에 있는 a 변수의 값과 밖에 있는 a의 값을 구분해봅시다. a &lt;- 10 myfunc &lt;- function(b){ a &lt;- b/2 return(a) } myfunc(a) cat(a) ## global vs local a &lt;- 10 myfunc &lt;- function(a){ a &lt;- a/10 return(a) } myfunc(a) cat(a) 5.2 Exercise 4-1: Matrix indexing 0으로 채워진 3 x 3 메트릭스를 만들고 가장자리 값들을 1로 채우는 연습을 해봅니다. M &lt;- matrix(0, nrow=3, ncol=3) M[,1] &lt;- 1 M[,3] &lt;- 1 M[1,] &lt;- 1 M[3,] &lt;- 1 5.3 Top-down design 탑다운 방식의 프로그래밍 디자인방법은 간략히 다음과 같은 순서로 진행합니다. 1) Divide a big problem into smaller problems, 2) keep dividing until the small problem can be solved easily, 3) Solve the small problems, 4) Merge the solutions to solve the big problem 이 방법으로 길찾기 로봇을 구현하기 위해서는 다음과 같이 문제를 세분화 하겠습니다. 먼저 구성물은 지도와 로봇이 있고 지도에는 시작점, 끝점, 막힌곳, 로봇은 현재 위치, 이동함수 (규칙) 등이 있으면 될 것 같습니다. 그리고 이러한 상황을 보여주기 위한 그리기 기능도 필요해 보입니다. 참고로 강사 생각이며 각자 다르게 생각할 수 있습니다. 좀 더 자세한 내용은 강의노트를 참고하세요. 5.4 Exercise 4-2: Draw world 먼저 로봇이 다니는 지도를 그리기 위해서 plot 함수를 사용합니다. plot 함수는 가장 기본이 되는 그래픽 함수로 입력 값에 따른 다양한 기능을 수행하는 함수입니다. 자세한 내용은 ?plot으로 도움말을 참고 하세요. 8 x 8 크기의 지도에서 격자를 다음과 같이 그릴 수 있습니다. plot(0, type=&quot;n&quot;, ylim=c(1,8), xlim=c(1,8)) lines(x=c(1,1), y=c(1,8)) lines(x=c(2,2), y=c(1,8)) lines(x=c(3,3), y=c(1,8)) lines(x=c(4,4), y=c(1,8)) lines(x=c(1,8), y=c(1,1)) lines(x=c(1,8), y=c(2,2)) lines(x=c(1,8), y=c(3,3)) lines(x=c(1,8), y=c(4,4)) 그런데 반복되는 lines 함수를 사용하는 패턴을 보실 수 있습니다. 이런 경우 다음과 같이 for 문을 이용할 수 있습니다. for 문의 i는 임의의 변수로 뒤에 오는 1:8 까지의 값을 한번씩 갖게 되며 각 값을 갖는 동안 { } 안의 코드를 8번 반복 실행하게 됩니다. 이 때 i에 저장된 값을 lines 파라메터 값을 사용하면 효율적으로 원하는 기능을 구현할 수 있습니다. 마지막 points 함수는 적당한 위치 (아래 예제에서는 x=3, y=3)의 위치에 pch=16 모양을 cex=3 만큼 크게 그리라는 명령입니다. ?points 또는 ?pch 등의 도움말을 참고 하세요. plot(0, type=&quot;n&quot;, ylim=c(1,8), xlim=c(1,8)) for(i in 1:8){ lines(x=c(i,i), y=c(1,8)) lines(x=c(1,8), y=c(i,i)) } points(3,3, pch=16, cex=3) 이제 앞서 코드들을 종합해서 map과 로봇을 그려주는 draw_world 라는 함수로 만들어 보겠습니다. 입력 파라메터는 현재 로봇의 위치인 cur_x, cur_y로 하고 지도를 그린 후 cur_x와 cur_y에 점(로봇)을 그리는 함수 입니다. 그리는 기능이 전부이므로 NULL을 리턴하도록 합니다 (웹페이지 작성 특성상 리턴 명령은 사용하지 않았습니다). 함수 내에서 n &lt;- 8 로 한 것은 그 아래 코드들에서 공통적으로 같은 값(지도 크기)을 사용하므로 변수에 값을 지정한 후 사용할 경우 혹시 지도의 사이즈가 변경된다고 해도 모든 값들을 바꾸지 않고 n 값만 바꿔서 쉽게 기능을 적용하기 위함 입니다. draw_world &lt;- function(cur_x, cur_y){ n &lt;- 8 plot(0, type=&quot;n&quot;, ylim=c(1,n), xlim=c(1,n)) for(i in 1:n){ lines(x=c(i,i), y=c(1,n)) lines(x=c(1,n), y=c(i,i)) } points(x=cur_x, y=cur_y, pch=16, cex=3) #return(NULL) } 위와 같이 코드를 작성한 후 한 번 실행하여 메모리에 함수를 등록 합니다. 이후 부터는 draw_world 호출만으로 구현한 기능을 사용할 수 있습니다. 아래는 그 사용 예 입니다. cur_x 또는 cur_y에 값을 변경하여 넣어 줄 때 마다 다른 위치에 점이 그려지는 것을 확인할 수 있습니다. cur_x &lt;- 1 cur_y &lt;- 1 draw_world(cur_x, cur_y) draw_world(cur_x+1, cur_y) draw_world(cur_x+1, cur_y+1) 5.5 Exercise 4-4: Generate map 위 코드까지 작성했다면 어떤 식으로 로봇이 움직이는 것을 보여줄 수 있을지 추측할 수 있을 것입니다. 로봇이 적당한 위치로 움직이게 하고 draw_world 함수를 호출하는 과정을 반복하면 되는 것입니다. 그럼 로봇이 어떻게 어디로 움직일지를 결정하기 위해서 매트릭스를 구성해 보겠습니다. 이 매트릭스는 가상의 지도로 0과 1로 채워져 있으며 0은 로봇이 갈 수 있는 곳 1은 로봇이 가지 못하는 곳으로 정하고 로봇이 랜덤하게 움직이며 이동한 곳이 0인지 1인지 검사해서 이동을 완료할지 아니면 그 전 위치에서 다시 움직일 곳을 찾을지를 결정하면 됩니다. 먼저 0으로 채워진 매트릭스를 만들고 가장자리는 로봇이 움직이지 못 하도록 1로 채우겠습니다. n&lt;-8 maze &lt;- matrix(0, nrow=n, ncol=n) maze[1,] &lt;- 1 maze[n,] &lt;- 1 maze[,1] &lt;- 1 maze[,n] &lt;- 1 이제 중앙 공간에서 이동하지 못하는 곳을 랜덤하게 정해서 넣겠습니다. 넣는 방법은 아래와 같습니다. 수업시간에 2차원 매트릭스의 인덱싱을 1차원처럼 해도 된다고 말씀 드렸습니다. 대신 인덱스 번호는 왼쪽 위로부터 1부터 시작해서 아래로 증가하고 해당 column의 길이 끝까지 간 후 다시 오른쪽 column 상단에서부터 시작되어 이어지는 인덱스 번호를 갖게 됩니다. 아래는 1부터 64까지 (가로 세로 8칸 이므로 64개) 인덱스 중 10개를 랜덤하게 뽑아서 해당 인덱스 자리의 값을 1로 채우는 코드 입니다. 앞서 가장자리를 1로 채운 곳과 겹치더라도 상관 없습니다. maze[sample(1:64,10)] &lt;- 1 maze ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 1 1 1 1 1 1 1 ## [2,] 1 0 0 0 0 0 0 1 ## [3,] 1 1 0 0 0 0 1 1 ## [4,] 1 0 0 0 0 0 0 1 ## [5,] 1 1 1 0 0 0 0 1 ## [6,] 1 0 0 1 0 0 0 1 ## [7,] 1 0 0 1 0 0 0 1 ## [8,] 1 1 1 1 1 1 1 1 이제 위 코드를 활용해서 maze matrix 맵을 만드는 함수인 generate_maze 를 작성해 봅니다. 입력 파라메터는 n 하나로 가로 또는 세로의 (정사각형) 갯수를 의미합니다. generate_maze &lt;- function(n){ maze &lt;- matrix(0, nrow=n, ncol=n) maze[1,] &lt;- 1 maze[n,] &lt;- 1 maze[,1] &lt;- 1 maze[,n] &lt;- 1 ## blocks maze[sample(1:(n*n),5)] &lt;- 1 maze } mymaze &lt;- generate_maze(8) mymaze ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 1 1 1 1 1 1 1 ## [2,] 1 0 0 0 1 1 0 1 ## [3,] 1 0 0 0 0 0 0 1 ## [4,] 1 0 0 0 0 0 0 1 ## [5,] 1 0 0 0 0 0 0 1 ## [6,] 1 0 1 0 0 0 0 1 ## [7,] 1 0 0 0 0 0 0 1 ## [8,] 1 1 1 1 1 1 1 1 5.6 Draw blocks and walls 이제 위에서 생성된 매트릭스를 기반으로 로봇이 가지 못하는 길을 사각형으로 그려넣어 맵을 완성합니다. 매트릭스가 8x8 일 경우 64개 포인트의 모든 값들을 비교하여 1일 경우 사각형을 그리는 코드를 만들면 되겠습니다. 이 때 값을 비교하기 위해 if 문을 사용할 수 있고 해당 값들을 비교하기 위해 아래와 같은 코드를 작성할 수 있습니다. if(mymaze[1,1]==1){ ## plot square } if(mymaze[1,2]==1){ ## plot square } if(mymaze[1,3]==1){ ## plot square } ... if(mymaze[2,1]==1){ ## plot square } if(mymaze[2,2]==1){ ## plot square } if(mymaze[2,3]==1){ ## plot square } ... 그러나 이런식으로 64개 값들을 모두 비교하는 것은 비효율적입니다. mymaze 매트릭스의 인덱스 번호가 row와 column각각 1부터 8까지 증가하는 것으로 보면 앞에서 배웠던 for 문을 사용해서 좀 더 효율적인 코드를 만들 수 있을 듯 합니다. 아래 코드에서 nrow와 ncol은 각각 해당 매트릭스의 행과 열의 갯수를 계산해 주는 함수들 입니다. 즉, for 문을 이용하여 row 만큼 반복하고 다시 그 안에서 for문을 한 번 더 사용하여 column 수만큼 반복을 하면 해당 매트릭스의 모든 값들을 참조할 수 있습니다. 아래는 mymaze[i,j]가 1일 경우 points 문을 이용하여 pch=22 인 모양을 cex=3 크기로 bg=“gray” 색으로 칠하는 코드입니다. draw_world(cur_x, cur_y) for(i in 1:nrow(mymaze)){ for(j in 1:nrow(mymaze)){ if(mymaze[i,j]==1){ points(i,j, pch=22, cex=3, bg=&quot;gray&quot;) } } } 이제 위 코드를 앞서 만들었던 draw_world 함수에 추가하여 draw_world 함수를 호출할 경우 완전한 맵과 적당한 위치의 로봇을 그려주도록 할 수 있습니다. 그런데 맵 정보는 generate_maze 함수로 생성한 매트릭스가 가지고 있으므로 생성된 맵의 정보를 draw_world 함수 내부에서 사용할 수 있도록 파라메터로 전달해서 넘겨주는 것이 필요합니다. 따라서 maze라는 파라메터를 draw_world 함수에 추가하고 함수 내부에 있던 n 값은 입력받은 매트릭스의 row 또는 column 수를 저장하도록 n &lt;- nrow(maze) 코드를 추가합니다. draw_world &lt;- function(maze, cur_x, cur_y){ n &lt;- nrow(maze) plot(0, type=&quot;n&quot;, ylim=c(1,n), xlim=c(1,n)) for(i in 1:n){ lines(x=c(i,i), y=c(1,n)) lines(x=c(1,n), y=c(i,i)) } for(i in 1:nrow(maze)){ for(j in 1:nrow(maze)){ if(maze[i,j]==1){ points(i,j, pch=22, cex=3, bg=&quot;gray&quot;) } } } points(x=cur_x, y=cur_y, pch=16, cex=3) } 이제 8 x 8 맵을 생성하고 랜덤하게 길을 막은 후 로봇을 x=2, y=2로 위치하게 한 완전한 지도를 그릴 수 있습니다. 참고로 여기서 draw_world 함수에서 maze 맵을 생성하도록 generate_maze에서 수행하는 코드와 비슷한 코드를 넣을 수 있습니다. 그러나 이럴 경우 한 함수에서 두 가지 이상의 작업을 수행하게 되므로 가독성, 함수 독립성, 유지보수 용이성이 낮아지면서 프로그램의 효율성이 떨어질 수 있습니다. cur_x &lt;- 2 cur_y &lt;- 2 mymaze &lt;- generate_maze(8) draw_world(mymaze, cur_x, cur_y) 5.7 Move one step 이제 로봇이 한 걸음을 옮기는 코드를 작성해 보겠습니다. 로봇은 현재 위치에서 4개의 방향으로 갈 수 있으나 이 중 막힌 길로는 갈 수 없습니다. 즉 현재 위치에서 동,서,남,북 중 하나의 방향을 랜덤하게 정하고 그 방향으로 한 걸음을 움직인 곳의 지도(매트릭스)상의 값이 0이면 이동한 위치 그대로 있고 1이면 다시 왔던 자리로 돌아가면 됩니다. next_x와 next_y를 cur_x, cur_y의 한 걸음 이후 위치라 정의하면 아래와 같이 정해진 방향으로 업데이트 한 후 next_x, next_y 위치에서 draw_world를 수행하면 됩니다. cur_x &lt;- 2 cur_y &lt;- 2 draw_world(mymaze, cur_x, cur_y) one_step_direction &lt;- sample(c(&quot;E&quot;,&quot;W&quot;, &quot;S&quot;, &quot;N&quot;), 1) if(one_step_direction==&quot;E&quot;){ next_x &lt;- cur_x + 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;W&quot;){ next_x &lt;- cur_x - 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;S&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y - 1 }else if(one_step_direction==&quot;N&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y + 1 } draw_world(mymaze, next_x, next_y) 5.8 Sleep for delay 그러나 위 코드를 실행하면 cur_x, cur_y 위치에 있을 때 그림은 보여지지 않고 마지막 next_x, next_y 위치 로봇에 대해서만 그림이 그려져 보이는 것을 알 수 있습니다. 이는 코드 문제라기 보다는 컴퓨터 반응시간 문제로 그림이 그려지기 전에 다른 그림이 그려지는 문제로 나타나는 현상 입니다. 따라서 Sys.sleep(1) 이라는 명령어로 1초 동안 코드 실행을 멈출 수 있고 그 동안 우리는 cur_x, cur_y 위치의 로봇이 그려지는 것을 볼 수 있습니다. 또한 위 코드는 지도상의 어디든 갈 수 있는 상태로 막힌 곳의 위치로는 움직이지 못 하도록 하는 코드가 필요합니다. 이를 위해 다음 마지막 부분의 if문처럼 코드를 업데이트하여 next_x, next_y 위치가 0일 경우에만 draw_world를 호출하여 그림을 업데이트 하고 그렇지 않으면 아무 일도 하지 않게 합니다. cur_x &lt;- 2 cur_y &lt;- 2 draw_world(mymaze, cur_x, cur_y) Sys.sleep(1) one_step_direction &lt;- sample(c(&quot;E&quot;,&quot;W&quot;, &quot;S&quot;, &quot;N&quot;), 1) if(one_step_direction==&quot;E&quot;){ next_x &lt;- cur_x + 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;W&quot;){ next_x &lt;- cur_x - 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;S&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y - 1 }else if(one_step_direction==&quot;N&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y + 1 } if(mymaze[next_x, next_y]==0){ draw_world(mymaze, next_x, next_y) } 5.9 Move 50 steps 이제 for 문을 이용해서 50 step 이동하는 것을 구현해 보겠습니다. 여기서 눈여겨 볼 부분은 마지막 next_x 와 next_y의 위치에 0일 경우 draw_world를 호출하지 않고 cur_x, cur_y 값을 업데이트 시켜서 효율적으로 구현했습니다. mymaze &lt;- generate_maze(8) cur_x &lt;- 2 cur_y &lt;- 2 for(i in 1:50){ draw_world(mymaze, cur_x, cur_y) Sys.sleep(1) one_step_direction &lt;- sample(c(&quot;E&quot;,&quot;W&quot;, &quot;S&quot;, &quot;N&quot;), 1) cat(i, &quot;/&quot;, one_step_direction, &quot;\\n&quot;);flush.console() if(one_step_direction==&quot;E&quot;){ next_x &lt;- cur_x + 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;W&quot;){ next_x &lt;- cur_x - 1 next_y &lt;- cur_y }else if(one_step_direction==&quot;S&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y - 1 }else if(one_step_direction==&quot;N&quot;){ next_x &lt;- cur_x next_y &lt;- cur_y + 1 } if(mymaze[next_x, next_y]==0){ cur_x &lt;- next_x cur_y &lt;- next_y } } "],
["lecture-05-multiple-plate-reader-file.html", "6 Lecture 05 - Multiple plate reader file 6.1 File I/O 파일 입출력 6.2 plot 산포도 6.3 hist 히스토그램 6.4 boxplot 상자그래프 6.5 barplot 막대그래프 6.6 other examples 그래프 예시 6.7 Multiplate reader 기능 구현 6.8 Multiplate reader function 만들기", " 6 Lecture 05 - Multiple plate reader file 강의노트와 실습용 엑셀파일은 다음을 참고 하세요 Lecture note design excel file data excel file 이번 시간에는 R에서 제공하는 기본 그래프 함수들을 간략하게 알아보고 지난 3번째 강의에서 간략하게 실습했던 multiple plate reader (\\(Victor^{TM}\\), PerkinElmer, Inc.) 장비를 통해 측정된 데이터를 읽어와서 분석하기 위한 함수를 작성해 보겠습니다. 생물학 실험에서 샘플의 실험 조건이 다양하게 달라지고 96 well plate상에서 측정된 위치 등이 수시로 바뀌는 등의 상황에 의존적이지 않고 해당 장비를 사용할 경우에 한해서는 일반적으로 사용할 수 있는 함수를 만드는 것이 목표 입니다. 6.1 File I/O 파일 입출력 먼저 지난 시간에 배웠던 파일 입출력 코드를 보겠습니다. write.table 함수는 택스트 파일로 해당 데이터를 저장합니다. ?write.table 도움말을 보시면 quote=TRUE로 모든 값들을 따옴표가 있는 문자로 저장합니다. 따라서 숫자형으로 저장하기 위해서는 quote=F를 명시해야 하며 read.table은 테이블 형태로 파일 내용을 읽어오며 반환되는 오브젝트 타입은 기본적으로 data.frame 입니다. x1 &lt;- c(1,2,5,7) y1 &lt;- c(1,6,7,8) xy&lt;-data.frame(x1, y1) write.table(xy, file=&quot;table_write.txt&quot;, quote=F) myxy &lt;- read.table(file=&quot;table_write.txt&quot;) myxy ## x1 y1 ## 1 1 1 ## 2 2 6 ## 3 5 7 ## 4 7 8 class(myxy) ## [1] &quot;data.frame&quot; names(myxy) ## [1] &quot;x1&quot; &quot;y1&quot; 6.2 plot 산포도 R에서 plot 함수는 가장 기본이 되는 그래프 함수 입니다. 아래는 산포도를 그려주는 코드로서 myxy가 두 개의 변수(x1과 y1)를 가지고 있으므로 아래 명령들은 모두 같은 그림을 그려주게 됩니다. 가장 마지막 명령은 formula를 사용한 plot으로 첫번째 파라메터 인자로 formula 타입이 전달되면 plot.formula 함수가 실행되며 x, y 값이 전달될 경우 plot.default 함수가 수행됩니다. R에서는 이렇게 전달되는 파라메터의 타입에 따라서 다른 기능을 하는 함수를 Generic function 이라고 합니다. plot(myxy) plot(myxy$x1, myxy$y1) plot(x=myxy$x1, y=myxy$y1) plot(y1~x1, data=myxy) 6.3 hist 히스토그램 hist는 데이터들의 분포를 히스토그램으로 그려주는 함수입니다. 히스토그램은 데이터들이 갖는 값을 특정 구간으로 나누고 각 구간에 해당하는 데이터가 몇 개인지 빈도수를 계산하여 막대그래프로 보여주는 함수 입니다. x &lt;- rnorm(100) hist(x, br=20, xlim=c(-3,3), main=&quot;Main text&quot;, xlab=&quot;X label&quot;) 6.4 boxplot 상자그래프 boxplot은 데이터의 여러가지 대표값 (중간값 median, 첫번째 사분위수 1st quantile, 세번째 사분위수 3rd quantile, 최소 minimum, 최대값 maximum) 등을 한눈에 볼 수 있도록 만들어놓은 그래프 입니다. boxplot(x) data.frame 타입의 오브젝트에 대해서 boxplot을 그릴 경우 여러 변수의 데이터들의 분포를 한눈에 비교할 수 있읍니다. y &lt;- rnorm(100, 1, 1) #boxplot(y) xy &lt;- data.frame(x, y) boxplot(xy) class(xy) ## [1] &quot;data.frame&quot; 6.5 barplot 막대그래프 막대그래프는 기존 수업에서도 실습을 진행한 그래프로 각 값들을 막대 형태로 나란히 배치하여 서로 비교가 용이하도록 만든 그래프 입니다. table 함수는 같은 값을 갖는 데이터들이 몇 개나 있는지 테이블을 만들어주는 함수 입니다. rbind는 두 변수를 row를 기준으로 붙여주는 역할의 함수입니다. x &lt;- sample(1:12, 200, replace = T) tab_x &lt;- table(x) y &lt;- sample(1:12, 200, replace = T) tab_y &lt;- table(y) tab_xy &lt;- rbind(tab_x, tab_y) #barplot(tab_xy) #barplot(tab_xy, beside = T) #barplot(tab_xy, beside = T, col=c(&quot;darkblue&quot;,&quot;red&quot;)) barplot(tab_xy, beside = T, col=c(&quot;darkblue&quot;,&quot;red&quot;), xlab=&quot;Month&quot;) barplot(tab_xy, beside = T, col=c(&quot;darkblue&quot;,&quot;red&quot;), xlab=&quot;Month&quot;, horiz=TRUE) 6.6 other examples 그래프 예시 위 예제들에서 사용한 high level function들을 low level function (lines, points, ablines, axis 등)들과 함께 사용함으로써 원하는 도표 대부분을 그려낼 수 있습니다. 최근 널리 사용되는 ggplot2 패키지를 이용한 그래프 사용법 강의에서는 오늘 배우는 그래픽 명령어는 거의 사용하지 않습니다. 그러나 위 함수들은 R의 기본 그래프 함수들로서 단순한 도표에서부터 복잡한 그래픽까지 구현할 수 있는 다양한 유연성을 제공하므로 기본적인 사용법을 정확히 이해하는 것이 필수입니다. 아래 도표는 평균 0, 분산 1인 분포에서 500개의 랜덤한 수를 뽑아 x에 저장하고 x의 분포를 히스토그램으로 표현한 것 입니다. x &lt;- rnorm(500) hist(x, 100) 아래는 앞서 생성한 x 값들과 상관성이 있는 y값들을 (x에 2를 곱하고 평균 5, 분산 1인 랜덤하게 뽑힌 수를 노이즈로 더함) 생성하고 모든 1000개 값들의 분포를 그린 히스토그램 입니다. 또한 density 함수와 lines 함수를 조합하여 확률밀도함수 커브를 그려 넣었습니다. 이 때 hist 함수에 probability=T 옵션을 넣어 y축의 스케일을 확률밀도함수의 y 스케일과 맞춰주어 같은 화면에 그려지도록 했습니다. y &lt;- 2*x + rnorm(500, mean=5, sd=1) z &lt;- c(x,y) hist(z, br=100, probability = T) lines(density(z)) 위에서 생성한 x, y 값의 산포도를 그리고 x축과 y축 범위를 xlim, ylim 파라메터로 조절했습니다. ?pch 도움말을 참고하여 다양한 포인트 모양을 선택할 수 있으며 x 값이 0 보다 작은 경우의 index를 뽑아 해당되는 x 값들과 그 값들의 짝이 되는 y값들에 대해서만 다시 포인트 그림을 red 색상으로 그려 넣었습니다. lm 은 linear model의 약자로 회귀 곡선을 구할 때 사용하는 함수이며 이 함수를 abline과 조합하여 회귀 직선을 그릴 수 있습니다. plot(x,y, xlim=c(-5, 5), ylim=c(-5, 15), pch=3) idx &lt;- which(x&lt;0) points(x[idx], y[idx], col=&quot;red&quot;) abline(lm(y~x)) 6.7 Multiplate reader 기능 구현 함수를 만들기 위한 프로그래밍 소개 및 전략 등의 내용은 강의노트를 참고하시기 바랍니다. 특히 exp_design.xlsx 파일은 실험 후 결과 측정을 위하여 96 well plate에 위치할 샘플들의 위치 및 실험 조건을 명시해둔 파일로서 이번 시간 만드는 함수의 핵심이 되는 파일입니다. 일반적으로 R에서 함수를 만들기 전에 해당 함수가 가진 기능들을 한줄 한줄 먼저 구현해서 확인한 후 함수 형태로 만들어 내는 것이 좋습니다. 먼저 excel 파일을 읽어오기 위하여 readxl 패키지를 불러온 후 read_excel 함수의 range 파라메터를 이용하여 96 well plate의 dimension과 같은 8 x 12 데이터를 모두 읽습니다. read_excel 함수는 기본적으로 tibble 형식의 데이터를 반환하지만 본 강의에서는 data.frame 형식으로 사용하기 위하여 as.data.frame 함수를 이용하여 변환을 해 줍니다. 참고로 최근 R을 이용한 데이터 분석에는 tibble 타입이 많이 쓰이는 추세입니다. #options(readxl.show_progress = FALSE) library(readxl) design_file_name &lt;- &quot;exp_design.xlsx&quot; data_file_name &lt;- &quot;Rprog04-fl.xls&quot; #mydesign &lt;- read_excel(design_file_name, sheet=1) mydesign &lt;- as.data.frame(read_excel(design_file_name, sheet=1, range=&quot;A1:L8&quot;, skip = 0, col_names=F)) mydata &lt;- as.data.frame(read_excel(data_file_name, sheet=1)) #head(mydesign) #head(mydata) ## New names: ## * `` -&gt; ...1 ## * `` -&gt; ...2 ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...5 ## * ... and 7 more problems ## New names: ## * Time -&gt; Time...5 ## * Time -&gt; Time...7 위 design 엑셀 파일로 샘플이 놓인 위치와 그 실험 조건을 읽어올 수 있으나 data를 뽑아올 수 있는 well의 이름인 (mydata 데이터 확인) A01, A02, …, B01, B02와 같은 이름 정보는 존재하지 않습니다. 이에 96 well plate 와 동일한 크기의 메트릭스를 만들고 각 셀에 well 이름들로 값을 넣어 추후 인덱스를 얻었을 때 그 위치에 해당하는 well 이름을 얻을 수 있도록 합니다. sprintf는 %02d와 같이 명시한 포맷으로 숫자를 출력해주는 함수 입니다. %02d는 digit 2자리 포맷을 가리키는 문자열로 한자리 숫자의 경우 앞에 0을 넣어 2자리로 만들어 출력해 줍니다. # make a position matrix pos1 &lt;- rep(LETTERS[1:8], time=12) pos2 &lt;- rep(sprintf(&quot;%02d&quot;, 1:12), each=8) well_position_labels &lt;- paste(pos1, pos2, sep=&quot;&quot;) well_position_matrix &lt;- matrix(well_position_labels, nrow=8, ncol=12) 이제 design 메트릭스에서 실험 조건이 명시된 위치의 well 이름을 꺼내오는 작업을 수행합니다. 이 때 바로 matrix에 대해서 코딩을 하기 보다는 vector 수준에서 값을 불러오는 코드를 먼저 만들고 matrix로 확장하는 것이 좋습니다. 아래는 첫 번째 컬럼의 값들에 대해서만 (vector 수준에서) 값을 추출하는 코드입니다. is.na는 해당 값이 NA인지 검사해서 NA일 경우 TRUE를 그렇지 않으면 FALSE를 리턴해주는 함수 입니다. ## vector tmpi &lt;- mydesign[, 1] tmpv &lt;- well_position_matrix[, 1] !is.na(tmpi) which(!is.na(tmpi)) tmpi[!is.na(tmpi)] tmpv[!is.na(tmpi)] 이제 위 코드를 함수로 만들고 lapply 함수를 사용하여 data.frame에 적용하도록 합니다. 함수는 다음 두 개의 함수(extract_values, extract_values2)로서 extract_value 함수는 입력되는 파라메터 벡터 x에서 na 가 아닌 값들을 추출하는 함수입니다. extract_value2는 다른 두 개의 메트리스를 파라메터로 넘겨서 값을 뽑기 위한 변형된 함수로 입력되는 파라메터 x가 16개의 값을 가지며 1부터 8까지 8개의 값들 중 na 가 아닌 인덱스를 뽑아내고 실제 값은 9부터 16까지의 8개 값들 중 해당하는 인덱스의 값을 뽑아내는 함수 입니다. extract_values &lt;- function(x){ index &lt;- which(!is.na(x)) return(x[index]) } #extract_values(tmpi) extract_values2 &lt;- function(x){ conditions &lt;- x[1:8] well_names &lt;- x[9:16] index &lt;- which(!is.na(conditions)) return(well_names[index]) } #extract_values2(c(tmpi, tmpv)) 이제 위 함수들, 특히extract_value2 함수을 이용해서 well 이름을 추출하기 위해서 mydesign과 well_position_matrix 두 메트릭스를 bind한 bound_matrix라는 메트릭스를 만들고 lapply로 extract_value 함수와 extract_value2 함수를 사용하여 well 이름과 well_condition을 각각 뽑아 냅니다. 마지막 well_info data.frame은 두 변수를 묶어놓은 것으로 data.frame 생성시 문자형이 factor형으로 자동 형 변환 되는 것을 막기 위하여 stingAsFactors = F 옵션을 추가해 줍니다. colnames(mydesign) &lt;- as.character(1:12) colnames(well_position_matrix) &lt;- as.character(1:12) bound_matrix &lt;- rbind(mydesign, well_position_matrix) tmpv &lt;- lapply(bound_matrix, extract_values2) well_names &lt;- unlist(tmpv) tmpv &lt;- lapply(mydesign, extract_values) well_conditions &lt;- unlist(tmpv) well_info &lt;- data.frame(well_names, well_conditions, stringsAsFactors = F) well_info에 명시된 well 이름에 해당하는 데이터를 mydata에서 추출하기 위해 match 함수를 사용합니다. match 함수는 두 개의 벡터에서 공통되는 값을 가진 인덱스를 뽑기 위한 함수 입니다. #dim(mydata) head(mydata) ## Plate Repeat Well Type Time...5 595nm_kk (A) Time...7 ## 1 1 1 B01 M 0.0001843750 0.7012086 0.0008273148 ## 2 1 1 B02 M 0.0001888889 0.7518509 0.0008320602 ## 3 1 1 B03 M 0.0001931713 0.7232866 0.0008368056 ## 4 1 1 B04 M 0.0001974537 0.7440926 0.0008415509 ## 5 1 1 B05 M 0.0002017361 0.7056004 0.0008462963 ## 6 1 1 B06 M 0.0002060185 0.7228400 0.0008510417 ## EGFP_sulim (Counts) ## 1 67809 ## 2 60025 ## 3 102745 ## 4 99979 ## 5 108175 ## 6 109575 head(well_info) ## well_names well_conditions ## 11 B01 1;1;0 ## 12 C01 1;2;0 ## 13 D01 2;1;0 ## 14 E01 2;2;0 ## 21 B02 1;1;10 ## 22 C02 1;2;10 mydata에는 well 이라는 변수에 well_info에는 well_names라는 변수에 우리가 비교하고자 하는 값들이 들어 있습니다. match 함수의 리턴 값은 첫번째 파라메터로 넘겨진 변수를 기준으로 해당 값들이 두 번째 파라메터 변수의 값에 해당하는 인덱스 입니다. 쉽게 혼동될 수 있으니 꼭 help를 참고해서 명확히 이해하시길 바랍니다. mydata에서 데이터를 뽑아야 하므로 아래처럼 well_info에 존재하는지 검사하고 존재하는 값들만 subset 함수를 사용해서 뽑아냅니다. # match(mydata$Well, well_info$well_names) tmpidx &lt;- match(mydata$Well, well_info$well_names) tmp_mydata_subset &lt;- subset(mydata, !is.na(tmpidx)) head(tmp_mydata_subset) ## Plate Repeat Well Type Time...5 595nm_kk (A) Time...7 ## 1 1 1 B01 M 0.0001843750 0.7012086 0.0008273148 ## 2 1 1 B02 M 0.0001888889 0.7518509 0.0008320602 ## 3 1 1 B03 M 0.0001931713 0.7232866 0.0008368056 ## 4 1 1 B04 M 0.0001974537 0.7440926 0.0008415509 ## 13 1 1 C01 M 0.0002644676 0.8026616 0.0009127315 ## 14 1 1 C02 M 0.0002687500 0.7750938 0.0009174769 ## EGFP_sulim (Counts) ## 1 67809 ## 2 60025 ## 3 102745 ## 4 99979 ## 13 42654 ## 14 33957 위 tmp_mydata_subset에서 우리가 필요한 정보는 well 이름과 OD, 형광값으로 각각 3번째 6번째 8번째 컬럼에 들어있습니다. 그러나 실험에서 OD 만 찍을 경우 8번째 컬럼은 존재하지 않게 됩니다. 즉, 이 부분이 실험 조건에 따라서 에러가 발생될 수 있는 부분이라 좀 더 일반적으로 사용 가능한 함수를 구현하기 위해서는 이 부분을 개선해줄 필요가 있습니다. OD, green 형광, red 형광을 측정할 경우 3, 6, 8, 10 번째 컬럼 순으로 데이터가 저장될 수 있습니다. 따라서 tmp_mydata_subset 의 컬럼 길이보다 작은 짝수만큼 컬럼을 선택하면되고 다음과 같이 간단히 코드를 작성할 수 있습니다 (3은 필수, 최소 하나의 데이터를 찍으면 6번째 컬럼에 들어가므로 시작은 6부터). sel_column &lt;- c(3, seq(6, ncol(tmp_mydata_subset), by=2)) mydata_subset &lt;- tmp_mydata_subset[,sel_column] head(mydata_subset) ## Well 595nm_kk (A) EGFP_sulim (Counts) ## 1 B01 0.7012086 67809 ## 2 B02 0.7518509 60025 ## 3 B03 0.7232866 102745 ## 4 B04 0.7440926 99979 ## 13 C01 0.8026616 42654 ## 14 C02 0.7750938 33957 이제 well_info와 mydata_subset을 하나의 data.frame으로 합하겠습니다. 하나의 오브젝트로 구성하는 것이 추후 그래프 작성이나 분석을 위해서 편리하기 때문입니다. merge라는 함수는 두 데이터셋을 각각 공통으로 가진 변수를 기준으로 합해주는 함수입니다. 단순히 cbind 등으로 두 데이터프레임을 붙여 놓을 경우 각각의 데이터 정렬 순서가 다르기 때문에 하나의 row에 다른 정보가 섞이게 됩니다. 따라서 두 데이터셋을 붙일 경우 위와 같이 공통되는 변수를 기준으로 적절히 정렬 후 붙이는 것이 필수입니다. 아래 코드의 by.x는 첫번째 파라메터로 넘겨진 오브젝트가 갖는 공통된 변수 이름이며 두번째 by.y는 두번째 파라메터로 넘겨진 오브젝트가 갖는 공통된 변수 이름 입니다. final_data &lt;- merge(well_info, mydata_subset, by.x=&quot;well_names&quot;, by.y=&quot;Well&quot;) head(final_data) ## well_names well_conditions 595nm_kk (A) EGFP_sulim (Counts) ## 1 B01 1;1;0 0.7012086 67809 ## 2 B02 1;1;10 0.7518509 60025 ## 3 B03 1;1;100 0.7232866 102745 ## 4 B04 1;1;1000 0.7440926 99979 ## 5 C01 1;2;0 0.8026616 42654 ## 6 C02 1;2;10 0.7750938 33957 이제 목적했던 함수를 만들기 전 마지막 단계로 실험 조건을 좀 더 보기 쉽게 바꿔보도록 하겠습니다. 위 데이터에 보시면 well_conditions 변수에 세 개의 실험 조건이 “;”으로 붙어 표현되어 있습니다. 각각 샘플이름, 반복횟수, 약품농도 입니다. 아래 strsplit 함수는 split에 명시된 문자를 기준으로 첫번째 파라메터 문자를 나누어 주는 기능을 수행합니다. 아래처럼 벡터연산이 가능하여 한번에 모든 컨디션 정보를 나누어 줄 수도 있습니다. 리턴값 형태는 리스트로서 unlist를 통해 벡터로 전환 가능 합니다. ## strsplit(&quot;1;1;0&quot;, split=&quot;;&quot;) ## unlist(strsplit(&quot;1;1;0&quot;, &quot;;&quot;)) tmp &lt;- strsplit(final_data$well_conditions, &quot;;&quot;) head(tmp) ## [[1]] ## [1] &quot;1&quot; &quot;1&quot; &quot;0&quot; ## ## [[2]] ## [1] &quot;1&quot; &quot;1&quot; &quot;10&quot; ## ## [[3]] ## [1] &quot;1&quot; &quot;1&quot; &quot;100&quot; ## ## [[4]] ## [1] &quot;1&quot; &quot;1&quot; &quot;1000&quot; ## ## [[5]] ## [1] &quot;1&quot; &quot;2&quot; &quot;0&quot; ## ## [[6]] ## [1] &quot;1&quot; &quot;2&quot; &quot;10&quot; 그런데 위와 같이 벡터연산을 수행하여 정보를 추출할 경우 목적하는 바에 따라서 불편한 점도 있습니다. 본 강의에서는 아래와 같이 하나의 백터로 조건 정보를 입력받아 값을 쪼갠 후 이름을 붙여주는 함수를 만들고 이를 apply 함수와 비슷한 기능의 sapply를 적용하도록 하겠습니다. sapply의 차이점은 help를 참고하세요. myparse &lt;- function(x){ tmp &lt;- unlist(strsplit(x, &quot;;&quot;)) names(tmp) &lt;- c(&quot;sample_names&quot;, &quot;replication&quot;, &quot;concentration&quot;) return(tmp) } tmpcond &lt;- sapply(final_data$well_conditions, myparse) head(tmpcond) ## 1;1;0 1;1;10 1;1;100 1;1;1000 1;2;0 1;2;10 1;2;100 1;2;1000 ## sample_names &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; ## replication &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; ## concentration &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; ## 2;1;0 2;1;10 2;1;100 2;1;1000 2;2;0 2;2;10 2;2;100 2;2;1000 ## sample_names &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; ## replication &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; ## concentration &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; &quot;0&quot; &quot;10&quot; &quot;100&quot; &quot;1000&quot; 각각 쪼개서 이름을 붙이는 작업 후 리턴된 결과를 보니 3 x 16 matrix 입니다. 앞서 우리가 구한 final_data와 나란히 붙여 넣기 위해서 t라는 함수를 사용하여 행과 열을 교환하는 transformation 을 수행합니다. 이제 merge 함수를 사용하여 붙여 넣어야 하는데 t_tmpcond 행렬에는 final_data와 같은 정보를 갖는 변수가 없습니다. 따라서 final_data의 well_conditions 와 같은 정보를 갖는 t_tmpcond의 rowname을 하나의 변수로 추가해 준 후 해당 공통 정보를 갖는 변수를 기준으로 두 오브젝트를 merge 해 줍니다. 마지막으로 well_conditions 정보는 중복이므로 제거해 주는 작업을 수행합니다. t_tmpcond &lt;- t(sapply(final_data$well_conditions, myparse)) t_tmpcond2 &lt;- cbind(t_tmpcond, rownames(t_tmpcond)) t_tmpcond2 &lt;- cbind(t_tmpcond, well_conditions=rownames(t_tmpcond)) final_data &lt;- merge(final_data, t_tmpcond2, by=&quot;well_conditions&quot;) final_data &lt;- final_data[,-1] head(final_data) ## well_names 595nm_kk (A) EGFP_sulim (Counts) sample_names replication ## 1 B01 0.7012086 67809 1 1 ## 2 B02 0.7518509 60025 1 1 ## 3 B03 0.7232866 102745 1 1 ## 4 B04 0.7440926 99979 1 1 ## 5 C01 0.8026616 42654 1 2 ## 6 C02 0.7750938 33957 1 2 ## concentration ## 1 0 ## 2 10 ## 3 100 ## 4 1000 ## 5 0 ## 6 10 6.8 Multiplate reader function 만들기 지금까지 수행한 코드들로 다음과 같은 함수를 만들 수 있습니다. read_multiplate_data &lt;- function(file_names){ design_file_name &lt;- file_names[1] data_file_name &lt;- file_names[2] # .... # .... code for the function ... # .... do it yourself ... # .... return(final_data) } 그리고 다음과 같이 엑셀 파일 이름만 넣어주면 원하는 데이터가 정리되어 나오게 됩니다. multiplate_file_names &lt;- c(&quot;exp_design.xlsx&quot;, &quot;Rprog04-fl.xls&quot;) myfinal_data &lt;- read_multiplate_data(multiplate_file_names) 함수의 기능은 앞서 설명드린 코드들로 대부분 구현 가능합니다. 물론 조금씩 더 신경쓸 부분이 있을 수 있으나 큰 오류는 없을 것으로 생각되며 구현중에 어려운 부분은 수업시간에 질문해 주시면 되겠습니다. "],
["lecture-06-multiple-plate-reader-ggplot.html", "7 Lecture 06 - Multiple plate reader / ggplot", " 7 Lecture 06 - Multiple plate reader / ggplot 실습용 엑셀파을 먼저 download 하세요 design excel file 2 data excel file 1 data excel file 2 data excel file 3 data excel file 4 "]
]
