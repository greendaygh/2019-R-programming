---
title: "09"
author: "Haseong"
date: "2019년 5월 8일"
output: html_document
---

# Lecture 09 - ggplot / dlyr for 96well fluorescence data

강의 노트 
[Lecture note](https://github.com/greendaygh/2019-R-programming/blob/master/09-Rprog.pdf)  

이번 시간에는 dplyr과 reshape2, 그리고 ggplot2를 이용하여 지난 수업들을 통해 만들었던 96well fluorescence 데이터에 대한 bar graph와 error bar를 구현해 보기로 하겠습니다. 계속 강조하는 바와 같이 R의 장점은 데이터 분석에 최적화된 언어 입니다. 데이터 분석에는 통계적 알고리즘을 적용하여 원하는 정보를 도출해내는 것이 핵심이지만 그 전에 가지고 있는 데이터를 눈으로 확인하는 작업이 필수이고 이를 위해 데이터를 적절히 변형하는 작업이 수없이 반복됩니다. dplyr과 reshape2 패키지는 이러한 데이터 변형 작업을 수행하기 위해 가장 선호되는 패키지들 중 하나이며 ggplot2 또한 데이터 가시화를 위해 가장 많이 쓰이는, 즉 가장 효율적인 패키지라고 할 수 있습니다. 이번 시간은 이러한 패키지들의 기본 사용법에 대해 설명하는 마지막 시간이 되겠습니다. 아래와 같이 관련 패키지들을 로딩해 주고 시작합니다. 

```{r}
library(ggplot2)
library(dplyr)
library(reshape2)
```


## dplyr functions 

지난 시간 학습한바와 같이 dplyr패키지에는 select, filter, group_by, summarize, arrange, join, mutate 등의 함수로 이루어져 있습니다. iris data를 가지고 몇 가지 함수에대한 실습을 하겠습니다. 먼저 select 함수는 특정 data.frame에서 원하는 variable을 뽑아주는 기능을 합니다. 첫번째 인자로 data.frame을 넣고 두 번째부터는 해당 data.frame에 있는 변수들 중 뽑고싶은 변수들의 이름을 넣습니다.  

```{r}
head(iris)
iris_select <- select(iris, Sepal.Length, Sepal.Width, Species)
head(iris_select)
```

select 함수는 관심있는 변수(column)를 뽑았다면 filter 함수는 관심있는 데이터(row)를 뽑는 함수로 생각하시면 됩니다. iris 데이터 중 Species 가 sentosa 인 데이터만 뽑고싶은 경우 다음과 같이 작성하면 됩니다. 주의할 점은 R의 기본 stats 패키지에도 filter라는 함수가 있어서 library(dplyr)로 dplyr 패키지를 읽지 않아도 실행은 되지만 문법이 달라서 에러가 뜰 수 있습니다. 

```{r}
str(iris)
iris_filter <- filter(iris, Species=="setosa")
str(iris_filter)
```

다음 group_by 함수는 데이터를 특정 기준으로 나누어주는 기능을 합니다. 예를 들어 iris 데이터에는 Species각 3졸류가 있고 group_by 함수는 이 3가지 species 별로 데이터를 나누어주는 함수입니다. 이 때 기준이 되는 변수는 factor형이어야 합니다. 

```{r}
str(iris_select)
iris_group <- group_by(iris_select, Species)
str(iris_group)
```

이제 summarize 함수를 이용해서 앞서 그룹별로 나누어진 데이터들의 summary를 구할 수 있습니다. 통계에서 summary는 데이터를 나타내는 대푯값으로 중앙을 나타내는 평균, 흩어진정도를 나타내는 분산(표준편차), 최대값, 최소값 등을 말합니다. summarize의 help를 참고하시면 되겠습니다. 앞서 Species 별로 그룹을 나누었고 각 그룹별로 sepal.length와 sepal.width에 대한 평균을 구하는 코드입니다.

```{r}
iris_mean <- summarise(iris_group, 
          mean(Sepal.Length), 
          mean(Sepal.Width))
head(iris_mean)
```


그런데 만약 sepal.length, sepal.width 외에도 petal.length, petal.with 등 해당 data.frame (tibble)의 모든 변수(컬럼)에 대한 평균을 구할 경우는 summarize_all 함수를 사용합니다. 위에서 mean(sepal.length) 등 모든 변수들에 대해서 같은 mean 함수를 적용하는 수고를 덜어주는 방법입니다. 

```{r}
iris_mean <- summarize_all(iris_group, mean)
head(iris_mean)
```

mean 외에도 앞에서 언급한바와 같이 sd, min, max 등의 함수를 적용하는 것이 가능합니다. 


```{r}
iris_sd <- summarize_all(iris_group, sd)
head(iris_sd)
```

ggplot을 이용하여 그래프를 그릴 때 모든 필요한 정보는 ggplot의 첫번째 인자로 들어가는 data.frame 안에 들어있어야 합니다. 즉, barplot을 그릴 때 mean 값과 error bar를 그릴 표준편차 (sd)값이 모두 하나의 data.frame 안에 있어야 하므로 앞에서 구한 iris_mean과 iris_sd를 합해서 하나의 data.frame으로 만들어야 합니다. 이렇게 두 데이터를 merge 할 때 주의할 점은 mean 값을 갖는 샘플과 같의 샘플에 sd 값을 붙여주어야 한다는 것 입니다. 즉, cbind로 mean 과 sd 컬럼을 막연히 가져다 붙이면 안되고 각 샘플이 같은지 확인 후 붙여야 합니다. 여기서 각 샘플이 같은지는 합 할 두 data.frame가 갖는 공통의 ID를 비교해서 알 수 있습니다. join 함수의 by 파라미터로 공통의 ID를 지정할 수 있습니다. inner_join, left_join, right_join 등 두 데이터셋의 ID가 같지 않을 경우에 대해서 다른 기능을 수행하는 몇 가지 함수들이 있습니다. 자세한 내용은 help페이지를 참고하세요. 본 예에서는 Species를 공통의 변수로 가지고 있으므로 ```by="Species"```로 명시해줍니다. 만약 같은 샘플 정보를 가지고 있으나 각 데이터에서 이름의 변수로 저장되어 있다면 해당 변수들의 이름을 ```c()``` 함수를 이용해서 함께 적어주면 되겠습니다.  


```{r}
iris_join <- inner_join(iris_mean, iris_sd, by="Species")
iris_join
```


## Data transformation using melt function 

지난 몇 번의 강의에서 언급한바와 같이 위 iris_join의 경우 처럼 다수의 변수를 갖는 데이터를 ggplot를 이용한 그래프로 표현하기 위해서는 (간단히 말해) 변수이름을 나타내는 변수 하나와 각 변수들의 값을 갖는 변수 하나, 해서 두 개의 변수로 가지고 있는 데이터를 변환해 주는 것이 필요합니다.  위 iris_join 데이터는 sepal.length.x와 sepal.width.x 평균 값을 갖는 변수 2개를 가지고 있는데, 이 데이터를 ggplot으로 그림을 그린다면 x축에는 species를 y축에는 평균을 그려야 하지만 y축 평균을 ```y=Sepal.Length.x``` 로 할지 ```y=Sepal.Width.x``` 를 할지 하나만을 골라야 합니다. geom_xxx 함수를 여러번 이용해서 다수의 변수 값들을 표현하는 방법이 있을 수 있으나 한정적인 그래프의 경우만 가능하고 변수가 많아질 경우 코드가 복잡해집니다. 

reshape2 패키지의 melt함수는 위에서 말한 데이터의 변환을 자동으로 수행해주는 함수 입니다. data.frame에 대해서 작동하는 경우만을 생각해 보면 (?melt.data.frame) id.vars 와 measure.vars 두 개의 파라메터를 볼 수 있습니다. id.vars 는 변환 전 관측값 외의 ID 가 될 수 있는 변수의 이름을 명시해 주고 measure.vars는 관측한 값이 저장된 변수를 모두 적어줄 수 있습니다. 각각의 입력 변수 이름은 사용자의 의도에 따라서 다르게 사용할 수 있습니다. iris_join 예에서는 Species를 제외한 모든 값들이 관측값이므로 다음과 같이 실행하면 되겠습니다. 가장 처음 column의 factor형 변수가 default로 id로 인식되므로 ```id.vars="Species"```를 적지 않아도 동일하게 작동합니다 (Species가 id로 사용된다는 메세지 출력).  

```{r}
melt(iris_join, id.vars="Species")
```


위 melt 함수의 파라메터 중 value.name 이라는 인자에는 value 라는 이름 대신 사용하고싶은 이름을 넣으면 되겠습니다. 그러나 위의 경우 mean과 sd 값이 모두 섞여있습니다. 그런데 우리가 그려줄 값은 mean 값이고 sd 는 error bar를 그리는데에만 사용될 것입니다. 즉, y축에는 평균만 그리므로 sd 값들은 제외하고 ggplot의 aes에서 y=value라는 코드를 사용할 수 있을 것 입니다. 

정리해 보면 위 melt 를 사용하기 전에 join으로 mean과 sd를 merge 했으나 실제로는 melt를 사용해서 모든 평균 값들을 하나의 변수에 저장하고 그 후 join으로 sd와 합하여 error bar를 그리는데 필요한 정보를 넘겨주는 것이 맞는 방법으로 보입니다. 이러한 일련의 작업들을 ``` %>% ```를 사용하여 아래 코드를 작성하였습니다.  



```{r}
iris_mean <- iris %>% group_by(Species) %>% summarise_all(mean) %>% melt(value.name="mean")
iris_sd <- iris %>% group_by(Species) %>% summarise_all(sd) %>% melt(value.name="sd")
iris_join <- inner_join(iris_mean, iris_sd, by=c("Species", "variable"))
iris_join
```



위 데이터는 모든 종류의 꽃잎과 꽃받침에 대한 평균과 표준편차를 하나의 테이블로 나타낸 최종 결과입니다. 이제 ggplot을 이용하여 평균을 그리고 각각에 대한 표준편차도 error bar로 표시할 수 있게 되었습니다. 지금까지의 데이터와 위치 조정을 통해서 그려진 bar graph는 다음과 같습니다.  

```{r}
p1 <- ggplot(iris_join, aes(x=Species, y=mean, fill=variable)) +
  geom_bar(stat="identity", position="dodge") +
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), 
                width=0.3, position=position_dodge(0.9))
p1
```


## scale and theme of ggplot2

이제 ggplot의 scale과 theme에 대해서 알아봅니다. 



